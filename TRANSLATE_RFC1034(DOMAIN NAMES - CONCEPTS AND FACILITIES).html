<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0035)http://srgia.com/docs/rfc1034j.html -->
<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
  
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>RFC1034(DOMAIN NAMES - CONCEPTS AND FACILITIES)</title>
  <style type="text/css">
  <!--
  BODY          { font-size: 14pt;
                  line-height: 120%;
                  padding: 0px 1em; }
  H1            { font-size: 14pt;
                  text-align: center; }
  H2            { font-size: 14pt;
                  font-weight: bold; }
  H3            { font-size: 14pt;
                  font-weight: bold; }
  H4            { font-size: 14pt;
                  font-weight: bold; }
  P             { text-indent: 1em;
                  margin-left: 2em;
                  margin-right: 0em; }
  PRE           { font-family: monospace;
                  font-size: 14pt;
                  margin-left: 2em;
                  line-height: 100%; }
  DL            { margin-left: 2em; }
  UL            { margin-left: 2em; padding-left: 2em; }
  LI            { margin-bottom: 1em; }
  DT            { margin-bottom: 1em; }
  DD            { margin-bottom: 1em; }
  A:link        { color: blue;
                  text-decoration: none; }
  A:visited     { color: purple;
                  text-decoration: none; }
  A:active      { color:red;
                  text-decoration: none; }
  .headleft     { float: left;
                  height: 5em;
                  width: 50%; }
  .headright    { float: right;
                  height: 5em;
                  text-align: right;
                  width: 50%; }
  .dir_link     { font-size: 10pt;
                  text-align: left;
                  margin-left: 0px;
                  margin-right: 0px;
                  padding: 2px 2px 2px 5px;
                  background-color: rgb(230,230,230);
                  border-style : solid;
                  border-width: 1px 0px 1px 0px;
                  border-color: rgb(0,0,0); }
  .notes        { margin-left:0em;
                  text-indent:0em;}
  .nomargin     { margin-left: 0em; }
  .noindent     { text-indent: 0em; }
  .menuindent   { margin-left: 2em; }
  .ad           { text-align: right;
                  font-size: 10pt; }
  .original     { color: blue;
                  display: none; }
  -->
  </style>
</head>
<body>

<iframe src="./TRANSLATE_RFC1034(DOMAIN NAMES - CONCEPTS AND FACILITIES)_files/cm.html" marginwidth="0" marginheight="0" width="728" height="90" border="0" frameborder="0" style="border: none; display: none !important;" scrolling="no"></iframe>

  <p class="dir_link">
    <a href="http://srgia.com/index.html">トップページ</a> - <a href="http://srgia.com/index.html#doc">翻訳ドキュメント</a> - RFC 1034
  </p>

<p style="margin-left:0em; text-indent:0em;">
原文：<a href="ftp://ftp.rfc-editor.org/in-notes/rfc1034.txt">ftp://ftp.rfc-editor.org/in-notes/rfc1034.txt</a><br>
原文との対訳として読みたい方へ：このページをローカルに保存して、スタイルシートの original クラスの display 属性を none から block に変更してみてください。
</p>

<hr>

<p class="nomargin noindent">
サイト内関連リンク：<a href="http://srgia.com/docs/rfc1035j.html">RFC 1035 DNS 実装と仕様</a>
</p>

<hr>

<div class="headleft">
 Network Working Group<br>
 Request for Comments: 1034<br>
 Obsoletes: RFCs 882, 883, 973<br>
 <br>
</div>
<div class="headright">
 P. Mockapetris<br>
 ISI<br>
 November 1987<br>
 <br>
</div>

<h1>
<span class="original">
                 DOMAIN NAMES - CONCEPTS AND FACILITIES
</span>
                     ドメイン名- 概念と機能
</h1>

<h2>
<span class="original">
1. STATUS OF THIS MEMO
</span>
1. この文書の位置付け
</h2>

<p>
<span class="original">
This RFC is an introduction to the Domain Name System (DNS), and omits
many details which can be found in a companion RFC, "Domain Names -
Implementation and Specification" [RFC-1035].  That RFC assumes that the
reader is familiar with the concepts discussed in this memo.
</span>
  この RFC は Domain Name System (DNS) の紹介であり、対になる RFC "DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION" [RFC-1035] に見られる多くの詳細を省略している。RFC 1035 は、読者がこの文書で議論されている概念を知っていることを前提としている。
</p>
<p>
<span class="original">
A subset of DNS functions and data types constitute an official
protocol.  The official protocol includes standard queries and their
responses and most of the Internet class data formats (e.g., host
addresses).
</span>
  DNS の機能とデータ型とのサブセットが公式なプロトコルを構成している。公式なプロトコルは標準問合せとその応答、そしてインターネットクラス(例えばホストアドレス)のデータフォーマットの大部分を含んでいる。
</p>
<p>
<span class="original">
However, the domain system is intentionally extensible.  Researchers are
continuously proposing, implementing and experimenting with new data
types, query types, classes, functions, etc.  Thus while the components
of the official protocol are expected to stay essentially unchanged and
operate as a production service, experimental behavior should always be
expected in extensions beyond the official protocol.  Experimental or
obsolete features are clearly marked in these RFCs, and such information
should be used with caution.
</span>
  しかしながら、ドメインシステムは任意に拡張可能である。研究者は新しいデータ型・問合せ型・クラス・機能などの提案、実装、実験を続けている。したがってこの公式なプロトコルの構成要素は本質的に変化せず、生産的サービスとして提供されることを期待される一方で、実験的作業は常にこの公式なプロトコルを越える拡張を期待されるべきである。試験的機能または非推奨の機能はこれらの RFC において明示されており、それらの情報は注意深く使用されるべきである。
</p>
<p>
<span class="original">
The reader is especially cautioned not to depend on the values which
appear in examples to be current or complete, since their purpose is
primarily pedagogical.  Distribution of this memo is unlimited.
</span>
  例に示されている値は主として教育目的のものであるため、読者はそれらを最新あるいは完全なものとして頼らないように、特に注意してほしい。この文書の配布に制限はない。
</p>

<h2>
<span class="original">
2. INTRODUCTION
</span>
2. 導入
</h2>

<p>
<span class="original">
This RFC introduces domain style names, their use for Internet mail and
host address support, and the protocols and servers used to implement
domain name facilities.
</span>
  この RFC はドメイン形式の名前、インターネットメールとホストアドレスとのためのその使用法、そしてドメイン名の機能を実装するために使用されるプロトコルとサーバーとを紹介する。
</p>

<h3>
<span class="original">
2.1. The history of domain names
</span>
2.1. ドメイン名の歴史
</h3>

<p>
<span class="original">
The impetus for the development of the domain system was growth in the
Internet:
</span>
  ドメインシステムの開発の推進力は、インターネットの成長であった：
</p>

<ul>
  <li>
    <span class="original">
   - Host name to address mappings were maintained by the Network
     Information Center (NIC) in a single file (HOSTS.TXT) which
     was FTPed by all hosts [RFC-952, RFC-953].  The total network
     bandwidth consumed in distributing a new version by this
     scheme is proportional to the square of the number of hosts in
     the network, and even when multiple levels of FTP are used,
     the outgoing FTP load on the NIC host is considerable.
     Explosive growth in the number of hosts didn't bode well for
     the future.
    </span>
    かつてホスト名からアドレスへのマッピング情報は、Network Information Center (NIC) が、すべてのホストから FTP 取得可能([RFC-952, RFC-953])な単一のファイル(HOSTS.TXT)に保持していた。この方法で新しいバージョンを配布するために消費されるネットワークの帯域幅は、ネットワーク内のホスト数の二乗に比例し、さらにマルチレベルの FTP が使用される場合、NIC ホストに掛かる FTP 出力の負荷は相当なものになる。ホスト数の爆発的増加はよい兆候ではなかった。
  </li>
  <li>
    <span class="original">
   - The network population was also changing in character.  The
     timeshared hosts that made up the original ARPANET were being
     replaced with local networks of workstations.  Local
     organizations were administering their own names and
     addresses, but had to wait for the NIC to change HOSTS.TXT to
     make changes visible to the Internet at large.  Organizations
     also wanted some local structure on the name space.
    </span>
    ネットワークの住人は性格の面でも変化していた。オリジナルの ARPANET を構成していたタイムシェアリングホストは、ワークステーションのローカルネットワークに置き換わりつつあった。ローカルの組織はその内部の名前とアドレスとを管理していたが、その変更の詳細がインターネットから見えるためには、HOSTS.TXT の変更を待たなければならなかった。組織は名前空間上に何らかのローカル構造を望んでいた。
  </li>
  <li>
    <span class="original">
   - The applications on the Internet were getting more
     sophisticated and creating a need for general purpose name
     service.
    </span>
    インターネット上のアプリケーションはますます複雑になり、汎用的な名前解決サービスを必要としていた。
  </li>
</ul>

<p>
<span class="original">
The result was several ideas about name spaces and their management
[IEN-116, RFC-799, RFC-819, RFC-830].  The proposals varied, but a
common thread was the idea of a hierarchical name space, with the
hierarchy roughly corresponding to organizational structure, and names
using "."  as the character to mark the boundary between hierarchy
levels.  A design using a distributed database and generalized resources
was described in [RFC-882, RFC-883].  Based on experience with several
implementations, the system evolved into the scheme described in this
memo.
</span>
  その結果、名前空間とその管理とに関するいくつかのアイデア [IEN-116, RFC-799, RFC-819, RFC-830] が生まれた。それらの提案はさまざまであったが、共通するのは階層型の名前空間で、組織の構造に大雑把に対応する階層と、階層レベル間の境界を表す文字として "." を使用する名前とを持っていた。分散されたデータベースと一般化されたリソースとを使用するための設計は [RFC-882, RFC-883] に記述された。いくつかの実装による経験を基に、そのシステムはこの文書で説明されている仕組みへと進化した。
</p>
<p>
<span class="original">
The terms "domain" or "domain name" are used in many contexts beyond the
DNS described here.  Very often, the term domain name is used to refer
to a name with structure indicated by dots, but no relation to the DNS.
This is particularly true in mail addressing [Quarterman 86].
</span>
  "ドメイン(domain)" または "ドメイン名(domain name)" という用語は、ここで説明される DNS 全体に渡り、多くの文脈で使用される。たいていの場合、ドメイン名という用語はドットで示される構造を持つ名前を参照するために使われるが、DNS とは無関係である。これはメールのアドレッシング [Quarterman 86] において特に顕著である。
</p>

<h3>
<span class="original">
2.2. DNS design goals
</span>
2.2. DNS の設計目標
</h3>

<p>
<span class="original">
The design goals of the DNS influence its structure.  They are:
</span>
  DNS の設計目標はその構造に影響を与えている。それらは以下の通り:
</p>

<ul>
  <li>
    <span class="original">
   - The primary goal is a consistent name space which will be used
     for referring to resources.  In order to avoid the problems
     caused by ad hoc encodings, names should not be required to
     contain network identifiers, addresses, routes, or similar
     information as part of the name.
    </span>
    第一の目標は、リソースを参照するために使用できる一貫性のある名前空間である。その場しのぎのエンコードによって引き起こされる問題を避けるために、名前はその一部としてネットワーク識別子やアドレスやルータなどの情報を含むことを必要としないべきである。
  </li>
  <li>
    <span class="original">
   - The sheer size of the database and frequency of updates
     suggest that it must be maintained in a distributed manner,
     with local caching to improve performance.  Approaches that
     attempt to collect a consistent copy of the entire database
     will become more and more expensive and difficult, and hence
     should be avoided.  The same principle holds for the structure
     of the name space, and in particular mechanisms for creating
     and deleting names; these should also be distributed.
    </span>
    データベース全体のサイズとその更新頻度は、パフォーマンスを改善するためのローカルキャッシュを伴なう配布手段によって維持されるべきであると提案する。データベース全体の完全なコピーの収集を試みるアプローチはますます高価かつ困難になるため、避けなければならない。名前空間の構造、特に名前の生成および削除(これらも配布されるべきである)のメカニズムにも、同じ原則が保たれるべきである。
  </li>
  <li>
    <span class="original">
   - Where there tradeoffs between the cost of acquiring data, the
     speed of updates, and the accuracy of caches, the source of
     the data should control the tradeoff.
    </span>
    情報を取得するコストと更新のスピードとキャッシュの正確さとの間にトレードオフがある場合、情報の発生源がそのトレードオフを制御する。
  </li>
  <li>
    <span class="original">
   - The costs of implementing such a facility dictate that it be
     generally useful, and not restricted to a single application.
     We should be able to use names to retrieve host addresses,
     mailbox data, and other as yet undetermined information.  All
     data associated with a name is tagged with a type, and queries
     can be limited to a single type.
    </span>
    このような機能を実装するコストは、それが一般に有用であり、単一アプリケーションに制限されないことを決定づける。ホストのアドレス、メールボックスの情報、そしてまだ未知の他の情報を取得するために、私たちは名前を利用できるべきである。ある名前に関連するすべての情報はタイプによってタグ付けされ、問合せを単独のタイプに限定することができる。
  </li>
  <li>
    <span class="original">
   - Because we want the name space to be useful in dissimilar
     networks and applications, we provide the ability to use the
     same name space with different protocol families or
     management.  For example, host address formats differ between
     protocols, though all protocols have the notion of address.
     The DNS tags all data with a class as well as the type, so
     that we can allow parallel use of different formats for data
     of type address.
    </span>
    私たちは異なるネットワークとアプリケーションとにおいて名前空間が役に立つことを望むため、異なるプロトコルファミリまたは異なる管理が、同じ名前空間を使用する能力を提供する。例えば、すべてのプロトコルはアドレスの概念を持つが、ホストアドレスのフォーマットはプロトコルによって異なる。アドレスの種類ごとの異なるフォーマットの並列使用を可能にするために、DNS はすべての情報にそのタイプだけでなく、クラスのタグも付ける。
  </li>
  <li>
    <span class="original">
   - We want name server transactions to be independent of the
     communications system that carries them.  Some systems may
     wish to use datagrams for queries and responses, and only
     establish virtual circuits for transactions that need the
     reliability (e.g., database updates, long transactions); other
     systems will use virtual circuits exclusively.
    </span>
    私たちは、ネームサーバーのトランザクションが通信システムから独立するようにしたい。システムによっては問合せと応答とにデータグラムを使用し、信頼性を必要とするトランザクション(例えばデータベースの更新、長いトランザクション)のためにだけ仮想通信路を構築することを望んでもよい。他のシステムでは仮想通信路を独占的に使用するだろう。
  </li>
  <li>
    <span class="original">
   - The system should be useful across a wide spectrum of host
     capabilities.  Both personal computers and large timeshared
     hosts should be able to use the system, though perhaps in
     different ways.
    </span>
    DNS システムは広範囲のホスト性能に渡って役に立つべきである。パーソナルコンピュータも巨大なタイムシェアリングホストも、おそらく異なる手段によるだろうが、このシステムを使用できるべきである。
  </li>
</ul>

<h3>
<span class="original">
2.3. Assumptions about usage
</span>
2.3. 使用法に関する仮定
</h3>

<p>
<span class="original">
The organization of the domain system derives from some assumptions
about the needs and usage patterns of its user community and is designed
to avoid many of the the complicated problems found in general purpose
database systems.
</span>
  ドメインシステムの組織化は、ユーザーコミュニティの必要性と利用パターンとに関するいくつかの仮定に由来しており、汎用目的のデータベースシステムに見られる複雑な問題の多くを避けるように設計されている。
</p>
<p>
<span class="original">
The assumptions are:
</span>
その仮定は以下の通り：
</p>

<ul>
  <li>
    <span class="original">
   - The size of the total database will initially be proportional
     to the number of hosts using the system, but will eventually
     grow to be proportional to the number of users on those hosts
     as mailboxes and other information are added to the domain
     system.
    </span>
    初めのうち、データベース全体のサイズはシステムを利用するホストの数に比例するだろう。しかしメールボックスやその他の情報がドメインシステムに追加されるため、最終的にはホスト上のユーザー数に比例するまで成長するだろう。
  </li>
  <li>
    <span class="original">
   - Most of the data in the system will change very slowly (e.g.,
     mailbox bindings, host addresses), but that the system should
     be able to deal with subsets that change more rapidly (on the
     order of seconds or minutes).
    </span>
    システム内の情報(例えばメールボックスの関連付け、ホストアドレス)の大部分は非常にゆっくりと変化するだろう。しかし、このシステムはもっと早く(秒または分のオーダーで)変化する集団も扱えるべきである。
  </li>
  <li>
    <span class="original">
   - The administrative boundaries used to distribute
     responsibility for the database will usually correspond to
     organizations that have one or more hosts.  Each organization
     that has responsibility for a particular set of domains will
     provide redundant name servers, either on the organization's
     own hosts or other hosts that the organization arranges to
     use.
    </span>
    通常、データベースの責任の分散に使用される管理境界は、一台以上のホストを持つ組織に相当する。ある特定のドメインの集合に責任を持つ各々の組織は、その組織内のホスト上か、その組織が使用するために準備した他のホスト上で、冗長なネームサーバーを提供するだろう。
  </li>
  <li>
    <span class="original">
   - Clients of the domain system should be able to identify
     trusted name servers they prefer to use before accepting
     referrals to name servers outside of this "trusted" set.
    </span>
    ドメインシステムのクライアントは、使用したいと望む "信頼された(trusted)" 集合の外部ネームサーバーへの参照を受け入れる前に、それらの信頼されたネームサーバーを識別できるべきである。
  </li>
  <li>
    <span class="original">
   - Access to information is more critical than instantaneous
     updates or guarantees of consistency.  Hence the update
     process allows updates to percolate out through the users of
     the domain system rather than guaranteeing that all copies are
     simultaneously updated.  When updates are unavailable due to
     network or host failure, the usual course is to believe old
     information while continuing efforts to update it.  The
     general model is that copies are distributed with timeouts for
     refreshing.  The distributor sets the timeout value and the
     recipient of the distribution is responsible for performing
     the refresh.  In special situations, very short intervals can
     be specified, or the owner can prohibit copies.
    </span>
    情報へのアクセス性は、即時更新や一貫性の保証よりも重要である。そのため更新プロセスは、すべてのコピーが同期して更新されることを保証するのではなく、ドメインシステムの利用者を通して徐々に浸透していく更新を認めている。ネットワークやホストの障害のために更新を利用できない場合の通常の方針は、更新する努力を続けながら、古い情報を信用することである。リフレッシュのためのタイムアウト値を持つコピーを配布するのが一般的なモデルである。配布する側がタイムアウト値を設定し、受け側がリフレッシュを実行する責任を持つ。特殊な状況では非常に短い間隔を指定してもよいし、コピーされることを所有者が拒否してもよい。
  </li>
  <li>
    <a name="INDEX-ITERATIVE"></a><a name="INDEX-RECURSIVE"></a>
    <span class="original">
   - In any system that has a distributed database, a particular
     name server may be presented with a query that can only be
     answered by some other server.  The two general approaches to
     dealing with this problem are "recursive", in which the first
     server pursues the query for the client at another server, and
     "iterative", in which the server refers the client to another
     server and lets the client pursue the query.  Both approaches
     have advantages and disadvantages, but the iterative approach
     is preferred for the datagram style of access.  The domain
     system requires implementation of the iterative approach, but
     allows the recursive approach as an option.
    </span>
    何であれ分散データベースを持つシステムでは、特定のサーバーが他のサーバーでないと答えられない問合せを受ける可能性がある。この問題を扱うための一般的なアプローチには、クライアントの問合せを受けた最初のサーバーが他のサーバーを呼び出す "再帰(recursive)" と、サーバーがクライアントに他のサーバーを参照させ、クライアントに問合せを発行させる "反復(iterative)" との二種類がある。この二つのアプローチはそれぞれに利点/欠点を持つが、データグラム型のアクセスでは反復アプローチが望ましい。ドメインシステムは反復アプローチの実装を必要とするが、オプションとして再帰アプローチも許可している。
  </li>
</ul>

<p>
<a name="INDEX-NAMESERVERS1"></a>
<span class="original">
The domain system assumes that all data originates in master files
scattered through the hosts that use the domain system.  These master
files are updated by local system administrators.  Master files are text
files that are read by a local name server, and hence become available
through the name servers to users of the domain system.  The user
programs access name servers through standard programs called resolvers.
</span>
  ドメインシステムでは、すべての情報はドメインシステムを利用するホスト間に分散されたマスターファイルにその起源を持つものと仮定する。マスターファイルはローカルのシステム管理者によって更新される。マスターファイルはローカルのネームサーバーによって読み込まれるテキストファイルであり、したがってドメインシステムの利用者からはネームサーバーを通して利用可能となる。ユーザープログラムは、リゾルバと呼ばれる標準プログラムを通してネームサーバーにアクセスする。
</p>
<p>
<span class="original">
The standard format of master files allows them to be exchanged between
hosts (via FTP, mail, or some other mechanism); this facility is useful
when an organization wants a domain, but doesn't want to support a name
server.  The organization can maintain the master files locally using a
text editor, transfer them to a foreign host which runs a name server,
and then arrange with the system administrator of the name server to get
the files loaded.
</span>
  マスターファイルの標準フォーマットはホスト間での(FTP、メール、またはその他のメカニズムを介しての)交換を可能にしている。ドメインを利用したいがネームサーバーはサポートしたくない組織の場合に、この機能が役に立つ。そのような組織はテキストファイルを用いてローカルのマスターファイルを保守し、ネームサーバーを実行している外部のホストにそれを送った後、そのネームサーバーのシステム管理者にファイルを読み込んでもらうように手配することができる。
</p>
<p>
<span class="original">
Each host's name servers and resolvers are configured by a local system
administrator [RFC-1033].  For a name server, this configuration data
includes the identity of local master files and instructions on which
non-local master files are to be loaded from foreign servers.  The name
server uses the master files or copies to load its zones.  For
resolvers, the configuration data identifies the name servers which
should be the primary sources of information.
</span>
  各ホストのネームサーバーとリゾルバは、ローカルのシステム管理者によって設定される[RFC-1033]。ネームサーバーの設定情報には、ローカルのマスターファイルの識別と、非ローカルのマスターファイルを外部サーバーから読み込む手順とが含まれる。ネームサーバーは自身のゾーンを読み込むために、マスターファイルまたはそのコピーを使用する。リゾルバの設定情報は、主要な情報源となるべきネームサーバーを特定する。
</p>
<p>
<span class="original">
The domain system defines procedures for accessing the data and for
referrals to other name servers.  The domain system also defines
procedures for caching retrieved data and for periodic refreshing of
data defined by the system administrator.
</span>
  ドメインシステムは、情報にアクセスするための手続きと、他のネームサーバーを参照するための手続きとを定義する。またドメインシステムは、取得した情報をキャッシュする手続きと、システム管理者によって決められる定期的な情報のリフレッシュの手続きも定義する。
</p>
<p>
<span class="original">
The system administrators provide:
</span>
  システム管理者が提供するもの:
</p>
<ul>
  <li>
    <span class="original">
   - The definition of zone boundaries.
    </span>
    ゾーン境界の定義
  </li>
  <li>
    <span class="original">
   - Master files of data.
    </span>
    情報のマスターファイル
  </li>
  <li>
    <span class="original">
   - Updates to master files.
    </span>
    マスターファイルの更新情報
  </li>
  <li>
    <span class="original">
   - Statements of the refresh policies desired.
    </span>
    望ましいリフレッシュポリシーの記述
  </li>
</ul>
<p>
<span class="original">
The domain system provides:
</span>
  ドメインシステムが提供するもの:
</p>
<ul>
  <li>
    <span class="original">
   - Standard formats for resource data.
    </span>
    リソース情報の標準フォーマット
  </li>
  <li>
    <span class="original">
   - Standard methods for querying the database.
    </span>
    データベースに問合せるための標準的手法
  </li>
  <li>
    <span class="original">
   - Standard methods for name servers to refresh local data from
     foreign name servers.
    </span>
    ネームサーバーが外部ネームサーバーからローカル情報をリフレッシュするための標準的手法
  </li>
</ul>

<h3>
<span class="original">
2.4. Elements of the DNS
</span>
2.4. DNS の要素
</h3>

<p>
<span class="original">
The DNS has three major components:
</span>
  DNS は三つの主要な構成要素を持つ：
</p>

<ul>
  <li>
    <span class="original">
   - The DOMAIN NAME SPACE and RESOURCE RECORDS, which are
     specifications for a tree structured name space and data
     associated with the names.  Conceptually, each node and leaf
     of the domain name space tree names a set of information, and
     query operations are attempts to extract specific types of
     information from a particular set.  A query names the domain
     name of interest and describes the type of resource
     information that is desired.  For example, the Internet
     uses some of its domain names to identify hosts; queries for
     address resources return Internet host addresses.
    </span>
    ツリー構造の名前空間であるドメイン名空間(DOMAIN NAME SPACE)と、名前に対応する情報の詳細であるリソースレコード(RESOURCE RECORDS)。概念的には、ドメイン名空間の各ノードとリーフは情報の集合を表し、問合せ操作はある特定の集合から特定のタイプの情報を抽出する試みである。問合せは関心のあるドメイン名を指名し、目的とするリソース情報のタイプを記述する。例えば、インターネットはホストを識別するためにドメイン名の一部を使用しており、アドレスリソースの問合せにはインターネットホストアドレスが返される。
  </li>
  <li>
    <span class="original">
   - NAME SERVERS are server programs which hold information about
     the domain tree's structure and set information.  A name
     server may cache structure or set information about any part
     of the domain tree, but in general a particular name server
     has complete information about a subset of the domain space,
     and pointers to other name servers that can be used to lead to
     information from any part of the domain tree.  Name servers
     know the parts of the domain tree for which they have complete
     information; a name server is said to be an AUTHORITY for
     these parts of the name space.  Authoritative information is
     organized into units called ZONEs, and these zones can be
     automatically distributed to the name servers which provide
     redundant service for the data in a zone.
    </span>
    ネームサーバー(NAME SERVERS)はドメインツリーの構造に関する情報を保持したり、情報を設定したりするためのサーバープログラムである。ネームサーバーはドメインツリーの任意の部分に関する構造をキャッシュしたり情報を設定したりしてよいが、一般にある特定のネームサーバーは、ドメイン空間のなかの小集団に関する完全な情報と、ドメインツリーの任意の部分から情報へと導くために使用される他のネームサーバーへのポインタとを持っている。各々のネームサーバーはドメインツリーのある部分の完全な情報を持っており、名前空間のその部分の<a name="INDEX-AUTHORITY"></a>権威(AUTHORITY)と呼ばれる。権威情報はゾーン(ZONE)と呼ばれる単位にまとめられ、冗長サービスを提供するネームサーバーへと自動的に配布することができる。
  </li>
  <li>
    <a name="INDEX-RESOLVERS"></a>
    <span class="original">
   - RESOLVERS are programs that extract information from name
     servers in response to client requests.  Resolvers must be
     able to access at least one name server and use that name
     server's information to answer a query directly, or pursue the
     query using referrals to other name servers.  A resolver will
     typically be a system routine that is directly accessible to
     user programs; hence no protocol is necessary between the
     resolver and the user program.
    </span>
    リゾルバ(RESOLVERS)はクライアントの要求に応じてネームサーバーから情報を抽出するプログラムである。リゾルバは少なくともひとつのネームサーバーにアクセス可能であり、問合せに直接答えるか、他のネームサーバーへの参照を使用して問合せを発行するために、そのネームサーバーの情報を使用しなければならない。典型的なリゾルバはユーザープログラムに直接アクセス可能なシステムルーチンであり、したがってリゾルバとユーザープログラムとの間にプロトコルは不要である。
  </li>
</ul>
<p>
<span class="original">
These three components roughly correspond to the three layers or views
of the domain system:
</span>
  これら三つの構成要素は、おおよそドメインシステムの三つのレイヤ、またはビューに対応する:
</p>
<ul>
  <li>
    <span class="original">
   - From the user's point of view, the domain system is accessed
     through a simple procedure or OS call to a local resolver.
     The domain space consists of a single tree and the user can
     request information from any section of the tree.
    </span>
    ユーザーの視点から見ると、ドメインシステムはローカルのリゾルバへの単純な手続きか OS コールかを通してアクセスされる。ドメイン空間は単一のツリーから構成され、ユーザーはそのツリーの任意の部分から情報を要求することができる。
  </li>
  <li>
    <span class="original">
   - From the resolver's point of view, the domain system is
     composed of an unknown number of name servers.  Each name
     server has one or more pieces of the whole domain tree's data,
     but the resolver views each of these databases as essentially
     static.
    </span>
    リゾルバの視点から見ると、ドメインシステムは未知数のネームサーバー群から構成される。各々のネームサーバーは完全なドメインツリー情報の中のひとつ以上の断片を持つが、リゾルバはそれらの各データベースを本質的に静的なものと見なす。
  </li>
  <li>
    <span class="original">
   - From a name server's point of view, the domain system consists
     of separate sets of local information called zones.  The name
     server has local copies of some of the zones.  The name server
     must periodically refresh its zones from master copies in
     local files or foreign name servers.  The name server must
     concurrently process queries that arrive from resolvers.
    </span>
    ネームサーバーの視点から見ると、ドメインシステムはゾーンと呼ばれるローカル情報の独立した集合から構成される。ネームサーバーはいくつかのゾーンのローカルコピーを持つ。ネームサーバーはローカルファイルや外部ネームサーバーのマスターのコピーを元に、そのゾーンを定期的にリフレッシュしなければならない。それと同時に、ネームサーバーはリゾルバからの問合せを処理しなければならない。
  </li>
</ul>
<p>
<span class="original">
In the interests of performance, implementations may couple these
functions.  For example, a resolver on the same machine as a name server
might share a database consisting of the the zones managed by the name
server and the cache managed by the resolver.
</span>
  パフォーマンスのために、実装はこれらの機能を合わせ持ってもよい。例えばネームサーバーと同じマシン上のリゾルバは、そのネームサーバーの管理するゾーンから構成されるデータベースと、リゾルバによって管理されるキャッシュとを共有してもよい。
</p>

<h2>
<span class="original">
3. DOMAIN NAME SPACE and RESOURCE RECORDS
</span>
3. ドメイン名空間(DOMAIN NAME SPACE)とリソースレコード(RESOURCE RECORDS)
</h2>

<h3>
<span class="original">
3.1. Name space specifications and terminology
</span>
3.1. 名前空間の仕様と用語
</h3>

<p>
<span class="original">
The domain name space is a tree structure.  Each node and leaf on the
tree corresponds to a resource set (which may be empty).  The domain
system makes no distinctions between the uses of the interior nodes and
leaves, and this memo uses the term "node" to refer to both.
</span>
  ドメイン名空間はツリー構造である。ツリー上の各ノードとリーフとはリソース集合(空でもよい)に対応する。ドメインシステムは内部のノードとリーフとの使用を区別しない。この文書ではこの両方を参照するために "ノード" という用語を使用する。
</p>
<p>
<a name="INDEX-LABEL"></a>
<span class="original">
Each node has a label, which is zero to 63 octets in length.  Brother
nodes may not have the same label, although the same label can be used
for nodes which are not brothers.  One label is reserved, and that is
the null (i.e., zero length) label used for the root.
</span>
  各ノードは、0 〜 63 オクテット長のラベルを持つ。兄弟でないノードは同じラベルを使用できるが、兄弟ノードは同じラベルを持ってはならない。ルートのために使用されるヌルラベル(すなわち長さゼロのラベル)は予約されている。
</p>
<p>
<a name="INDEX-DOMAINNAME"></a>
<span class="original">
The domain name of a node is the list of the labels on the path from the
node to the root of the tree.  By convention, the labels that compose a
domain name are printed or read left to right, from the most specific
(lowest, farthest from the root) to the least specific (highest, closest
to the root).
</span>
  あるノードのドメイン名は、そのノードからツリーのルートまでのパス上のラベルをリストしたものである。習慣的に、ドメイン名を構成するラベルは左から右へ、つまりもっとも特化した部分(最下位で、もっともルートから遠い部分)から、もっとも特化していない部分(最上位で、もっともルートに近い部分)へと、印字されたり読まれたりする。
</p>
<p>
<span class="original">
Internally, programs that manipulate domain names should represent them
as sequences of labels, where each label is a length octet followed by
an octet string.  Because all domain names end at the root, which has a
null string for a label, these internal representations can use a length
byte of zero to terminate a domain name.
</span>
  内部的には、ドメイン名を扱うプログラムはドメイン名を一連のラベルとして表現するべきである。各々のラベルはレングスオクテットの後にオクテット文字列が続く。すべてのドメイン名はラベルにヌル文字列を持つルートで終了するため、内部表現はドメイン名を終わらせるためのゼロのレングスバイトを使用することができる。
</p>
<p>
<a name="INDEX-CASEOFCHARACTERS"></a>
<span class="original">
By convention, domain names can be stored with arbitrary case, but
domain name comparisons for all present domain functions are done in a
case-insensitive manner, assuming an ASCII character set, and a high
order zero bit.  This means that you are free to create a node with
label "A" or a node with label "a", but not both as brothers; you could
refer to either using "a" or "A".  When you receive a domain name or
label, you should preserve its case.  The rationale for this choice is
that we may someday need to add full binary domain names for new
services; existing services would not be changed.
</span>
  習慣的にドメイン名は自由に大文字・小文字で保存できるが、現状のドメインの機能は、すべて ASCII 文字セットで高次ビットが 0 であると仮定し、大文字・小文字を区別せずに実行する。これは、ラベル "A" を持つノードもラベル "a" を持つノードも自由に生成できるが、両方を兄弟として生成することは出来ず、"a" でも "A" でも参照できることを意味する。ドメイン名またはラベルを受け取ったとき、その大文字・小文字を保持しておくべきである。その論理的根拠は、いつか新しいサービスのために完全にバイナリのドメイン名を追加するかもしれず、その時に既存のサービスを変更しなくても良いようにするためである。
</p>
<p>
<span class="original">
When a user needs to type a domain name, the length of each label is
omitted and the labels are separated by dots (".").  Since a complete
domain name ends with the root label, this leads to a printed form which
ends in a dot.  We use this property to distinguish between:
</span>
  ユーザーがドメイン名をタイプしなければならない場合、ラベルの長さは省略され、各ラベルはドット(".")で分離される。完全なドメイン名はルートラベルで終了するため、印刷形式ではドットで終了することになる。私たちは以下のものを区別するためにこの特徴を使用する：
</p>
<ul>
  <li>
    <a name="INDEX-ABSOLUTENAME"></a>
    <span class="original">
   - a character string which represents a complete domain name
     (often called "absolute").  For example, "poneria.ISI.EDU."
    </span>
    完全なドメイン名を表す文字列(しばしば "絶対(absolute)" と呼ばれる)。例えば、"poneria.ISI.EDU."。
  </li>
  <li>
    <span class="original">
   - a character string that represents the starting labels of a
     domain name which is incomplete, and should be completed by
     local software using knowledge of the local domain (often
     called "relative").  For example, "poneria" used in the
     ISI.EDU domain.
    </span>
    未完成のドメイン名の頭からのラベル群を表し、ローカルソフトウェアがローカルドメインの知識を使用して完成させなければならない文字列(しばしば "相対(relative)" と呼ばれる)。例えば、ドメイン ISI.EDU 内で使用される "poneria"。
  </li>
</ul>
<p>
<a name="INDEX-RELATIVENAMES"></a>
<span class="original">
Relative names are either taken relative to a well known origin, or to a
list of domains used as a search list.  Relative names appear mostly at
the user interface, where their interpretation varies from
implementation to implementation, and in master files, where they are
relative to a single origin domain name.  The most common interpretation
uses the root "." as either the single origin or as one of the members
of the search list, so a multi-label relative name is often one where
the trailing dot has been omitted to save typing.
</span>
  相対名は、既知の基点か検索リストとして使用されるドメインリストかに対する相対と見なされる。相対名が見られるのは主に、実装によって解釈の異るユーザーインターフェイスと、単一の基点ドメイン名への相対名となるマスターファイル中とである。もっとも一般的な解釈では、ルートの "." を単独の基点または検索リストのメンバーのひとつとして使用するため、複数ラベルから成る相対名は、しばしばタイピングを減らすために最後のドットを省略した形になる。
</p>
<p>
<span class="original">
To simplify implementations, the total number of octets that represent a
domain name (i.e., the sum of all label octets and label lengths) is
limited to 255.
</span>
  実装を簡単にするために、ドメイン名を表す総オクテット数(すなわち、すべてのラベルオクテットとラベル長の合計)は 255 までに制限される。
</p>
<p>
<span class="original">
A domain is identified by a domain name, and consists of that part of
the domain name space that is at or below the domain name which
specifies the domain.  A domain is a subdomain of another domain if it
is contained within that domain.  This relationship can be tested by
seeing if the subdomain's name ends with the containing domain's name.
For example, A.B.C.D is a subdomain of B.C.D, C.D, D, and " ".
</span>
  ドメインはドメイン名によって識別され、そのドメインを特定するドメイン名そのもの、またはその下位のドメイン名空間の該当部分から構成される。あるドメインが別のドメインの中に含まれる場合、それはそのドメインのサブドメインである。サブドメインの名前がそれを含むドメイン名で終わっているかどうかを見ることで、この関係を確認することができる。例えば A.B.C.D は、B.C.D、C.D、D、" " のサブドメインである。
</p>

<h3>
<span class="original">
3.2. Administrative guidelines on use
</span>
3.2. 利用上の管理ガイドライン
</h3>

<p>
<span class="original">
As a matter of policy, the DNS technical specifications do not mandate a
particular tree structure or rules for selecting labels; its goal is to
be as general as possible, so that it can be used to build arbitrary
applications.  In particular, the system was designed so that the name
space did not have to be organized along the lines of network
boundaries, name servers, etc.  The rationale for this is not that the
name space should have no implied semantics, but rather that the choice
of implied semantics should be left open to be used for the problem at
hand, and that different parts of the tree can have different implied
semantics.  For example, the IN-ADDR.ARPA domain is organized and
distributed by network and host address because its role is to translate
from network or host numbers to names; NetBIOS domains [RFC-1001, RFC-
1002] are flat because that is appropriate for that application.
</span>
  ポリシーの問題として、DNS の技術的仕様は、特定のツリー構造やラベル選択のための規則を強制しない。その意図は、任意のアプリケーションを構築するのに使用できるように、できる限り一般化することである。特にこのシステムは、名前空間をネットワーク境界やネームサーバー等の区分に沿ってまとめる必要が無いように設計された。その論理的根拠は、名前空間が暗黙の意味を持たないべきであるという事ではなく、むしろ暗黙の意味の選択がその問題のためにすぐに使用され得るようオープンであるべきという事である。つまり、ツリーの異なる部分では異なる暗黙の意味を持つことが可能ということである。例えばドメイン IN-ADDR.ARPA は、その役割がネットワークまたはホストの番号を名前に変換することなので、ネットワークとホストとのアドレスによってまとめられ、配布される。NetBIOS ドメイン [RFC-1001, RFC-1002] はフラットである。なぜなら、それがそのアプリケーションに適しているためである。
</p>
<p>
<span class="original">
However, there are some guidelines that apply to the "normal" parts of
the name space used for hosts, mailboxes, etc., that will make the name
space more uniform, provide for growth, and minimize problems as
software is converted from the older host table.  The political
decisions about the top levels of the tree originated in RFC-920.
Current policy for the top levels is discussed in [RFC-1032].  MILNET
conversion issues are covered in [RFC-1031].
</span>
  しかしながら、ホストやメールボックス等に使用される名前空間の "通常(normal)" の部分に適用されるガイドラインがいくつか存在しており、それは名前空間を画一化し、成長に備え、ソフトウェアを過去のホストテーブルから変換する場合の問題を最小化する。ツリーのトップレベルに関する政治的決定は RFC-920 を基礎にしている。トップレベルに対する現在のポリシーは [RFC-1032] で議論されている。MILNET 変換の問題は [RFC-1031] で網羅されている。
</p>
<p>
<span class="original">
Lower domains which will eventually be broken into multiple zones should
provide branching at the top of the domain so that the eventual
decomposition can be done without renaming.  Node labels which use
special characters, leading digits, etc., are likely to break older
software which depends on more restrictive choices.
</span>
  いずれ複数のゾーンに分割されるであろう下位ドメインは、最終的な分割を改名なしに実行できるように、そのドメインの最上位で分岐を提供しておくべきである。特殊文字や数字で始まるようなノードラベルは、より限定的な選択に依存する古いソフトウェアに問題を起こさせる可能性がある。
</p>

<h3>
<span class="original">
3.3. Technical guidelines on use
</span>
3.3. 使用に関する技術的ガイドライン
</h3>

<p>
<span class="original">
Before the DNS can be used to hold naming information for some kind of
object, two needs must be met:
</span>
  DNS が何らかのオブジェクトの名前情報を保持できるようになる前に、二つの要求事項を満たさなければならない:
</p>
<ul>
  <li>
    <span class="original">
   - A convention for mapping between object names and domain
     names.  This describes how information about an object is
     accessed.
    </span>
    オブジェクト名とドメイン名とをマッピングするための規定。これはオブジェクトに関する情報がどのようにアクセスされるかを記述する。
  </li>
  <li>
    <span class="original">
   - RR types and data formats for describing the object.
    </span>
    オブジェクトを記述するための RR のタイプとデータフォーマット。
  </li>
</ul>
<p>
<span class="original">
These rules can be quite simple or fairly complex.  Very often, the
designer must take into account existing formats and plan for upward
compatibility for existing usage.  Multiple mappings or levels of
mapping may be required.
</span>
  これらの規則は非常に単純にすることも、極めて複雑にすることもできる。多く場合、設計者は既存のフォーマットを考慮したり、既存の利用法に対する上位互換性を計画したりしなければならない。複数のマッピングやマッピングの階層が要求されてもよい。
</p>
<p>
<span class="original">
For hosts, the mapping depends on the existing syntax for host names
which is a subset of the usual text representation for domain names,
together with RR formats for describing host addresses, etc.  Because we
need a reliable inverse mapping from address to host name, a special
mapping for addresses into the IN-ADDR.ARPA domain is also defined.
</span>
  ホストの場合のマッピングは、ドメイン名の通常のテキスト表現のサブセットであるホスト名のための既存文法に基き、ホストアドレス等を記述するための RR フォーマットを伴う。私たちはアドレスからホスト名への信頼できる逆マッピングも必要とするので、ドメイン IN-ADDR.ARPA への特殊なマッピングも定義されている。
</p>
<p>
<a name="INDEX-MAILBOXNAMES"></a>
<span class="original">
For mailboxes, the mapping is slightly more complex.  The usual mail
address &lt;local-part&gt;@&lt;mail-domain&gt; is mapped into a domain name by
converting &lt;local-part&gt; into a single label (regardless of dots it
contains), converting &lt;mail-domain&gt; into a domain name using the usual
text format for domain names (dots denote label breaks), and
concatenating the two to form a single domain name.  Thus the mailbox
HOSTMASTER@SRI-NIC.ARPA is represented as a domain name by
HOSTMASTER.SRI-NIC.ARPA.  An appreciation for the reasons behind this
design also must take into account the scheme for mail exchanges [RFC-
974].
</span>
  メールボックスのマッピングは少し複雑である。通常のメールアドレス &lt;local-part&gt;@&lt;mail-domain&gt; は、&lt;local-part&gt; を(その中のドットに関係なく)単独のラベルに変換し、さらに &lt;mail-domain&gt; をドメイン名の通常のテキストフォーマットを使用してドメイン名に変換し、そして単一のドメイン名を形成するためにその二つをつなげることで、ドメイン名へとマップされる。したがってメールボックス HOSTMASTER@SRI-NIC.ARPA は、HOSTMASTER.SRI-NIC.ARPA というドメイン名として表現される。この設計を正しく評価するには、メールエクスチェンジ [RFC-974] の仕組みを考慮しなければならない。
</p>
<p>
<span class="original">
The typical user is not concerned with defining these rules, but should
understand that they usually are the result of numerous compromises
between desires for upward compatibility with old usage, interactions
between different object definitions, and the inevitable urge to add new
features when defining the rules.  The way the DNS is used to support
some object is often more crucial than the restrictions inherent in the
DNS.
</span>
  典型的なユーザーがこれらの規則の定義を意識することはない。しかしこれらが、過去の習慣との上位互換性の要望に対する多くの妥協と、異なるオブジェクト定義間の相互関係と、この規則を定義する際に新しい機能を追加するという避け難い衝動との結果だということを理解するべきである。何らかのオブジェクトをサポートするために DNS が使用される方法は、DNS 固有の制約よりも、しばしばより重要である。
</p>

<h3>
<span class="original">
3.4. Example name space
</span>
3.4. 名前空間の例
</h3>

<p>
<span class="original">
The following figure shows a part of the current domain name space, and
is used in many examples in this RFC.  Note that the tree is a very
small subset of the actual name space.
</span>
  以下の図は現在のドメイン名空間の一部を示しており、この RFC の多くの例で使用されている。このツリーは実際の名前空間の非常に小さいサブセットであることに注意してほしい。
</p>
<pre>                                   |
                                   |
             +---------------------+------------------+
             |                     |                  |
            MIL                   EDU                ARPA
             |                     |                  |
             |                     |                  |
       +-----+-----+               |     +------+-----+-----+
       |     |     |               |     |      |           |
      BRL  NOSC  DARPA             |  IN-ADDR  SRI-NIC     ACC
                                   |
       +--------+------------------+---------------+--------+
       |        |                  |               |        |
      UCI      MIT                 |              UDEL     YALE
                |                 ISI
                |                  |
            +---+---+              |
            |       |              |
           LCS  ACHILLES  +--+-----+-----+--------+
            |             |  |     |     |        |
            XX            A  C   VAXA  VENERA Mockapetris
</pre>
<p>
<span class="original">
In this example, the root domain has three immediate subdomains: MIL,
EDU, and ARPA.  The LCS.MIT.EDU domain has one immediate subdomain named
XX.LCS.MIT.EDU.  All of the leaves are also domains.
</span>
  この例において、ルートドメインは三つの直接のサブドメイン MIL・EDU・ARPA を持つ。ドメイン LCS.MIT.EDU は直接のサブドメイン XX.LCS.MIT.EDU を持つ。またリーフもすべてドメインである。
</p>

<h3>
<span class="original">
3.5. Preferred name syntax
</span>
3.5. 好ましい名前構文
</h3>

<p>
<span class="original">
The DNS specifications attempt to be as general as possible in the rules
for constructing domain names.  The idea is that the name of any
existing object can be expressed as a domain name with minimal changes.
However, when assigning a domain name for an object, the prudent user
will select a name which satisfies both the rules of the domain system
and any existing rules for the object, whether these rules are published
or implied by existing programs.
</span>
  DNS 仕様はドメイン名の構築の規則において、可能な限り一般化されるように試みられている。どの既存オブジェクトの名前も、最小限の変更でドメイン名として表現できるようにするという考え方である。しかしながらあるオブジェクトにドメイン名を割当てるとき、慎重なユーザーはそのオブジェクトに、ドメインシステムの規則と既存の規則(それが公開されているものであろうと、既存プログラムによって必要とされているものであろうと)との両方を満足する名前を選択するだろう。
</p>
<p>
<span class="original">
For example, when naming a mail domain, the user should satisfy both the
rules of this memo and those in RFC-822.  When creating a new host name,
the old rules for HOSTS.TXT should be followed.  This avoids problems
when old software is converted to use domain names.
</span>
  例えばメールドメインに名前を付ける場合、ユーザーはこの文書の規則と RFC-822 の規則との両方を満足させるべきである。また新しいホスト名を作成する場合、HOSTS.TXT のための過去の規則にしたがうべきである。これによって、過去のソフトウェアをドメイン名を使用するように変更する際の問題を避けられる。
</p>
<p>
<span class="original">
The following syntax will result in fewer problems with many
applications that use domain names (e.g., mail, TELNET).
</span>
  以下の構文にしたがうと、ドメイン名を使用する多くのアプリケーション(例えばメールや TELNET)において、問題がより少なくなるだろう。
</p>
<pre class="original">&lt;domain&gt; ::= &lt;subdomain&gt; | " "

&lt;subdomain&gt; ::= &lt;label&gt; | &lt;subdomain&gt; "." &lt;label&gt;

&lt;label&gt; ::= &lt;letter&gt; [ [ &lt;ldh-str&gt; ] &lt;let-dig&gt; ]

&lt;ldh-str&gt; ::= &lt;let-dig-hyp&gt; | &lt;let-dig-hyp&gt; &lt;ldh-str&gt;

&lt;let-dig-hyp&gt; ::= &lt;let-dig&gt; | "-"

&lt;let-dig&gt; ::= &lt;letter&gt; | &lt;digit&gt;

&lt;letter&gt; ::= any one of the 52 alphabetic characters A through Z in
upper case and a through z in lower case

&lt;digit&gt; ::= any one of the ten digits 0 through 9
</pre>
<pre>&lt;domain&gt; ::= &lt;subdomain&gt; | " "

&lt;subdomain&gt; ::= &lt;label&gt; | &lt;subdomain&gt; "." &lt;label&gt;

&lt;label&gt; ::= &lt;letter&gt; [ [ &lt;ldh-str&gt; ] &lt;let-dig&gt; ]

&lt;ldh-str&gt; ::= &lt;let-dig-hyp&gt; | &lt;let-dig-hyp&gt; &lt;ldh-str&gt;

&lt;let-dig-hyp&gt; ::= &lt;let-dig&gt; | "-"

&lt;let-dig&gt; ::= &lt;letter&gt; | &lt;digit&gt;

&lt;letter&gt; ::= 大文字の A から Z と小文字の a から z の、アルファベット
52 文字の内の任意の一文字

&lt;digit&gt; ::= 0 から 9 までの 10 個の数字の内の任意の一文字
</pre>
<p>
<span class="original">
Note that while upper and lower case letters are allowed in domain
names, no significance is attached to the case.  That is, two names with
the same spelling but different case are to be treated as if identical.
</span>
  ドメイン名には大文字も小文字も許されるが、それには重要な違いがないことに注意してほしい。つまり、同じつづりで大文字・小文字の異なる二つの名前は同じ物として扱われるということである。
</p>
<p>
<span class="original">
The labels must follow the rules for ARPANET host names.  They must
start with a letter, end with a letter or digit, and have as interior
characters only letters, digits, and hyphen.  There are also some
restrictions on the length.  Labels must be 63 characters or less.
</span>
  ラベルは ARPANET のホスト名の規則にしたがわなければならない。ラベルは文字で始まり、文字または数字で終わり、間には文字・数字・ハイフンだけが含まれなければならない。ラベルの長さにも制約があり、63 文字以下でなければならない。
</p>
<p>
<span class="original">
For example, the following strings identify hosts in the Internet:
</span>
  例えば以下の文字列はインターネット上のホストを識別する:
</p>
<pre>A.ISI.EDU  XX.LCS.MIT.EDU  SRI-NIC.ARPA
</pre>

<h3>
<span class="original">
3.6. Resource Records
</span>
3.6. リソースレコード
</h3>

<p>
<a name="INDEX-RR"></a>
<span class="original">
A domain name identifies a node.  Each node has a set of resource
information, which may be empty.  The set of resource information
associated with a particular name is composed of separate resource
records (RRs).  The order of RRs in a set is not significant, and need
not be preserved by name servers, resolvers, or other parts of the DNS.
</span>
  ドメイン名はノードを識別する。各々のノードはリソース情報の集合(空でもよい)を持つ。ある特定の名前に対応するリソース情報の集合は、個別のリソースレコード(RR)から構成される。集合の中の RR の順序は重要ではなく、ネームサーバーやリゾルバやその他の DNS の要素がその順序を保存する必要はない。
</p>
<p>
<span class="original">
When we talk about a specific RR, we assume it has the following:
</span>
  私たちがある特定の RR に付いて述べるとき、それは以下の内容を持つと仮定する：
</p>

<dl>
  <dt>
    <span class="original">
    owner
    </span>
    所有者
  </dt>
  <dd>
    <span class="original">
      which is the domain name where the RR is found.
    </span>
    その RR を見つけられるドメイン名。
  </dd>

  <dt>
    <span class="original">
    type
    </span>
    タイプ
  </dt>
  <dd>
    <span class="original">
    which is an encoded 16 bit value that specifies the type
    of the resource in this resource record.  Types refer to
    abstract resources.
    </span>
    エンコードされた 16 ビット値で、そのリソースレコード内のリソースの種類を表す。タイプは抽象リソースを表す。
  </dd>
  <dd>
    <span class="original">
    This memo uses the following types:
    </span>
    この文書では以下のタイプを使用する:
    <dl>
      <dt><a name="INDEX-A"></a>A</dt>
      <dd>
        <span class="original">
          a host address
        </span>
        ホストアドレス
      </dd>
      
      <dt><a name="INDEX-CNAME1"></a>CNAME</dt>
      <dd>
        <span class="original">
        identifies the canonical name of an alias
        </span>
        別名の正式な名前を特定する
      </dd>
      
      <dt><a name="INDEX-HINFO"></a>HINFO</dt>
      <dd>
        <span class="original">
        identifies the CPU and OS used by a host
        </span>
        ホストが使用する CPU と OS を特定する
      </dd>
      
      <dt><a name="INDEX-MX"></a>MX</dt>
      <dd>
        <span class="original">
        identifies a mail exchange for the
        domain.  See [RFC-974 for details.
        </span>
        そのドメインのメールエクスチェンジを特定する。詳細は [RFC-974] を参照してほしい。
      </dd>
      
      <dt><a name="INDEX-NS"></a>NS</dt>
      <dd>
        <span class="original">
        the authoritative name server for the domain
        </span>
        そのドメインに対して権威を持つネームサーバー
      </dd>
      
      <dt><a name="INDEX-PTR"></a>PTR</dt>
      <dd>
        <span class="original">
        a pointer to another part of the domain name space
        </span>
        ドメイン名空間の別の部分へのポインタ
      </dd>
      
      <dt><a name="INDEX-SOA"></a>SOA</dt>
      <dd>
        <span class="original">
        identifies the start of a zone of authority
        </span>
        権威を持つゾーンの開始を表す
      </dd>
    </dl>
  </dd>

  <dt>
    <span class="original">
    class
    </span>
    クラス
  </dt>
  <dd>
    <span class="original">
    which is an encoded 16 bit value which identifies a
    protocol family or instance of a protocol.
    </span>
    エンコードされた 16 ビット値で、プロトコルファミリーまたはプロトコルのインスタンスを表す。
  </dd>
  <dd>
    <span class="original">
    This memo uses the following classes:
    </span>
    この文書では以下のクラスを使用する:
    <dl>
      <dt><a name="INDEX-IN"></a>IN</dt>
      <dd>
        <span class="original">
        the Internet system
        </span>
        インターネット
      </dd>
      
      <dt><a name="INDEX-CH"></a>CH</dt>
      <dd>
        <span class="original">
        the Chaos system
        </span>
        カオスシステム
      </dd>
    </dl>
  </dd>
      
  <dt><a name="INDEX-TTL1"></a>TTL</dt>
  <dd>
    <span class="original">
    which is the time to live of the RR.  This field is a 32
    bit integer in units of seconds, an is primarily used by
    resolvers when they cache RRs.  The TTL describes how
    long a RR can be cached before it should be discarded.
    </span>
    RR の生存期間。このフィールドは秒単位の 32 ビット整数値で、主にリゾルバが RR をキャッシュする際に使用する。TTL は RR が破棄されるまでにどれだけの時間キャッシュされてよいかを記述したものである。
  </dd>

  <dt><a name="INDEX-RDATA"></a>RDATA</dt>
  <dd>
    <span class="original">
    which is the type and sometimes class dependent data
    which describes the resource:
    </span>
    そのリソースを説明する情報である。タイプと、場合によってはクラスに依存する:
    <dl>
      <dt>A</dt>
      <dd>
        <span class="original">
        For the IN class, a 32 bit IP address
        </span>
        IN クラスの場合、32 ビット IP アドレス
      </dd>
      <dd>
        <span class="original">
        For the CH class, a domain name followed
        by a 16 bit octal Chaos address.
        </span>
        CH クラスの場合、16 ビットの 8 進数カオスアドレスが続くドメイン名。
      </dd>
      
      <dt><a name="INDEX-CNAME2"></a>CNAME</dt>
      <dd>
        <span class="original">
        a domain name.
        </span>
        ドメイン名
      </dd>
      
      <dt>MX</dt>
      <dd>
        <span class="original">
        a 16 bit preference value (lower is
        better) followed by a host name willing
        to act as a mail exchange for the owner
        domain.
        </span>
        16 ビットの優先順位(小さい方が優先順位が高い)の後に、所有ドメインのメールエクスチェンジとして動作させようとするホスト名が続く。
      </dd>
        
      <dt>NS</dt>
      <dd>
        <span class="original">
        a host name.
        </span>
        ホスト名
      </dd>
        
      <dt>PTR</dt>
      <dd>
        <span class="original">
        a domain name.
        </span>
        ドメイン名
      </dd>
        
      <dt>SOA</dt>
      <dd>
        <span class="original">
        several fields.
        </span>
        いくつかのフィールド
      </dd>
    </dl>
  </dd>
</dl>
<p>
<span class="original">
The owner name is often implicit, rather than forming an integral part
of the RR.  For example, many name servers internally form tree or hash
structures for the name space, and chain RRs off nodes.  The remaining
RR parts are the fixed header (type, class, TTL) which is consistent for
all RRs, and a variable part (RDATA) that fits the needs of the resource
being described.
</span>
  多くの場合、所有者名は RR の必須要素とされるのではなく、暗黙的である。例えば多くのネームサーバーは、名前空間のためのツリーとハッシュ構造とを内部的に形成し、ノードを鎖状に繋ぐ。RR の残りの要素は、すべての RR において変化しない固定ヘッダ(タイプ、クラス、TTL)と、リソースを説明するための可変部分(右辺値(RDATA))である。
</p>
<p>
<a name="INDEX-TTL2"></a>
<span class="original">
The meaning of the TTL field is a time limit on how long an RR can be
kept in a cache.  This limit does not apply to authoritative data in
zones; it is also timed out, but by the refreshing policies for the
zone.  The TTL is assigned by the administrator for the zone where the
data originates.  While short TTLs can be used to minimize caching, and
a zero TTL prohibits caching, the realities of Internet performance
suggest that these times should be on the order of days for the typical
host.  If a change can be anticipated, the TTL can be reduced prior to
the change to minimize inconsistency during the change, and then
increased back to its former value following the change.
</span>
  TTL フィールドは、RR をキャッシュに保持できる制限時間を表す。この制限時間は権威を持つゾーン内の情報には適用されない。権威を持つゾーン内の情報もタイムアウトはするが、それはそのゾーンのリフレッシュポリシーによるものである。TTL は、その情報の源であるゾーンの管理者によって割当てられる。キャッシュされる時間を短くするために短い TTL を使用してもよいし、キャッシュされるのを拒否するために TTL をゼロにしてもよい。しかしながら、現実のインターネットのパフォーマンスを考えると、一般的なホストでは日単位にするべきである。前もって変更を予期できる場合、その変更による不一致を最小化するために、変更前に TTL を減らし、変更後に前の値に戻すことができる。
</p>
<p>
<span class="original">
The data in the RDATA section of RRs is carried as a combination of
binary strings and domain names.  The domain names are frequently used
as "pointers" to other data in the DNS.
</span>
  RR の RDATA 部のデータは、バイナリ文字列とドメイン名との組合わせとして転送される。ドメイン名はしばしば DNS の別の情報への "ポインタ(pointers)" として使用される。
</p>

<h4>
<span class="original">
3.6.1. Textual expression of RRs
</span>
3.6.1. RR のテキスト表現
</h4>

<p>
<span class="original">
RRs are represented in binary form in the packets of the DNS protocol,
and are usually represented in highly encoded form when stored in a name
server or resolver.  In this memo, we adopt a style similar to that used
in master files in order to show the contents of RRs.  In this format,
most RRs are shown on a single line, although continuation lines are
possible using parentheses.
</span>
  RR は DNS プロトコルのパケット内ではバイナリ形式で表現され、ネームサーバーやリゾルバの内部に保存される場合には高度にエンコードされて表現されるのが通常である。この文書では RR の内容を表すために、マスターファイル内で使用されるスタイルに似た形式を採用する。括弧を使って行を続けることも可能だが、この形式では大抵の RR は単一行で表される。
</p>
<p>
<span class="original">
The start of the line gives the owner of the RR.  If a line begins with
a blank, then the owner is assumed to be the same as that of the
previous RR.  Blank lines are often included for readability.
</span>
  行の先頭には RR の所有者が示される。行が空白で始まる場合、その所有者は直前の RR の所有者と同じであると見なされる。可読性のために、しばしば空行が含められる。
</p>
<p>
<span class="original">
Following the owner, we list the TTL, type, and class of the RR.  Class
and type use the mnemonics defined above, and TTL is an integer before
the type field.  In order to avoid ambiguity in parsing, type and class
mnemonics are disjoint, TTLs are integers, and the type mnemonic is
always last. The IN class and TTL values are often omitted from examples
in the interests of clarity.
</span>
  所有者に続けて、RR の TTL・タイプ・クラスが示される。クラスとタイプは前述のニーモニックを使用し、TTL はタイプフィールドの前に置かれる整数値である。解析の際のあいまいさを避けるために、タイプとクラスのニーモニックは分離される。TTL は整数であり、タイプのニーモニックは常に最後にくる。明快さのために、例ではしばしば IN クラスと TTL 値とを省略している。
</p>
<p>
<span class="original">
The resource data or RDATA section of the RR are given using knowledge
of the typical representation for the data.
</span>
  RR のリソース情報または RDATA 部は、その情報の一般的表現の知識を使用して与えられる。
</p>
<p>
<span class="original">
For example, we might show the RRs carried in a message as:
</span>
  例えば、メッセージ内で運ばれる RR を以下のように表す：
</p>
<pre>    ISI.EDU.        MX      10 VENERA.ISI.EDU.
                    MX      10 VAXA.ISI.EDU.
    VENERA.ISI.EDU. A       128.9.0.32
                    A       10.1.0.52
    VAXA.ISI.EDU.   A       10.2.0.27
                    A       128.9.0.33
</pre>
<p>
<span class="original">
The MX RRs have an RDATA section which consists of a 16 bit number
followed by a domain name.  The address RRs use a standard IP address
format to contain a 32 bit internet address.
</span>
  MX RR の RDATA 部は、16 ビット値と、その後にドメイン名とが続く。アドレス RR は 32 ビットのインターネットアドレスを含むために、標準的 IP アドレスフォーマットを使用する。
</p>
<p>
<span class="original">
This example shows six RRs, with two RRs at each of three domain names.
</span>
  上の例は 6 つの RR を表しており、三つのドメインがそれぞれ二つの RR を持っている。
</p>
<p>
<span class="original">
Similarly we might see:
</span>
  同じような例:
</p>
<pre>    XX.LCS.MIT.EDU. IN      A       10.0.0.44
                    CH      A       MIT.EDU. 2420
</pre>
<p>
<span class="original">
This example shows two addresses for XX.LCS.MIT.EDU, each of a different
class.
</span>
  この例は XX.LCS.MIT.EDU の二つのアドレスを表しており、それぞれクラスが異なる。
</p>

<h4>
<a name="INDEX-ALIASES1"></a>
<span class="original">
3.6.2. Aliases and canonical names
</span>
3.6.2. 別名と正規名
</h4>

<p>
<span class="original">
In existing systems, hosts and other resources often have several names
that identify the same resource.  For example, the names C.ISI.EDU and
USC-ISIC.ARPA both identify the same host.  Similarly, in the case of
mailboxes, many organizations provide many names that actually go to the
same mailbox; for example Mockapetris@C.ISI.EDU, Mockapetris@B.ISI.EDU,
and PVM@ISI.EDU all go to the same mailbox (although the mechanism
behind this is somewhat complicated).
</span>
  既存の組織において、ホストやその他のリソースは、しばしば同じリソースを識別する複数の名前を持つ。例えば、C.ISI.EDU と USC-ISIC.ARPA とは同じホストを表す。同様にメールボックスの場合、多くの組織は実際には同じメールボックスに届く複数の名前を提供する。例えば、Mockapetris@C.ISI.EDU と Mockapetris@B.ISI.EDU、PVM@ISI.EDU とは、(たとえその背景のメカニズムが多少複雑であったとしても)同じメールボックスに届く。
</p>
<p>
<span class="original">
Most of these systems have a notion that one of the equivalent set of
names is the canonical or primary name and all others are aliases.
</span>
  このような組織の多くは、その同等な名前のなかのひとつが正統または主要な名前であり、他の名前はすべて別名であるという概念を持つ。
</p>
<p>
<span class="original">
The domain system provides such a feature using the canonical name
(CNAME) RR.  A CNAME RR identifies its owner name as an alias, and
specifies the corresponding canonical name in the RDATA section of the
RR.  If a CNAME RR is present at a node, no other data should be
present; this ensures that the data for a canonical name and its aliases
cannot be different.  This rule also insures that a cached CNAME can be
used without checking with an authoritative server for other RR types.
</span>
  そのような特徴を、ドメインシステムは正規名 (CNAME) RR によって提供する。CNAME RR はその所有者名を別名として識別し、対応する正規名を RR の RDATA 部に指定する。ノードに CNAME RR が与えられる場合、他の情報は現れるべきではない。これにより、正規名と別名との情報に差異がないことを保証できる。またこの規則は、他の RR タイプの権威サーバーに確認すること無く、キャッシュされた CNAME を使用できることを保証する。
</p>
<p>
<span class="original">
CNAME RRs cause special action in DNS software.  When a name server
fails to find a desired RR in the resource set associated with the
domain name, it checks to see if the resource set consists of a CNAME
record with a matching class.  If so, the name server includes the CNAME
record in the response and restarts the query at the domain name
specified in the data field of the CNAME record.  The one exception to
this rule is that queries which match the CNAME type are not restarted.
</span>
  CNAME RR は DNS ソフトウェアに特別な動作を起こさせる。ドメイン名に対応するリソース集合の中から目的の RR を見つけるのに失敗したネームサーバーは、そのリソース集合に同一クラスの CNAME レコードが含まれるかどうかを確認する。もし含まれるなら、ネームサーバーは応答にその CNAME レコードを含め、その CNAME レコードのデータフィールド内で特定されるドメイン名で問合せを再開する。この規則にはひとつの例外があり、CNAME タイプを検索する問合せの場合は再開しない。
</p>
<p>
<span class="original">
For example, suppose a name server was processing a query with for USC-
ISIC.ARPA, asking for type A information, and had the following resource
records:
</span>
  例えば、ネームサーバーが USC-ISIC.ARPA のタイプ A を求める問合せを処理しており、以下のリソースレコードを持っていると仮定する：
</p>
<pre>    USC-ISIC.ARPA   IN      CNAME   C.ISI.EDU

    C.ISI.EDU       IN      A       10.0.0.52
</pre>
<p>
<span class="original">
Both of these RRs would be returned in the response to the type A query,
while a type CNAME or * query should return just the CNAME.
</span>
  タイプ A の問合せへの応答には、これら両方の RR が返される。一方、タイプ CNAME または * の問合せには CNAME だけが返される。
</p>
<p>
<span class="original">
Domain names in RRs which point at another name should always point at
the primary name and not the alias.  This avoids extra indirections in
accessing information.  For example, the address to name RR for the
above host should be:
</span>
  別の名前を指す RR 内のドメイン名は、別名ではなく常に主要な名前を指すべきである。これは情報にアクセスする際の余分な遠回りを避ける。例えば、上記のホストのための RR を指すアドレスは、USC-ISIC.ARPA ではなく、以下のようにするべきである：
</p>
<pre>    52.0.0.10.IN-ADDR.ARPA  IN      PTR     C.ISI.EDU
</pre>
<p>
<span class="original">
rather than pointing at USC-ISIC.ARPA.  Of course, by the robustness
principle, domain software should not fail when presented with CNAME
chains or loops; CNAME chains should be followed and CNAME loops
signalled as an error.
</span>
  当然ながら堅牢性の原則によって、ドメインソフトウェアは CNAME のチェーンやループに陥っても正常に機能するべきである。CNAME チェーンは処理が続けられ、CNAME ループはエラーとして通知されるべきである。
</p>

<h3>
<span class="original">
3.7. Queries
</span>
3.7. 問合せ
</h3>

<p>
<span class="original">
Queries are messages which may be sent to a name server to provoke a
response.  In the Internet, queries are carried in UDP datagrams or over
TCP connections.  The response by the name server either answers the
question posed in the query, refers the requester to another set of name
servers, or signals some error condition.
</span>
  問合せは応答を引き出すためにネームサーバーに送られるメッセージである。インターネットにおいて、問合せは UDP データグラムまたは TCP 接続を通して伝えられる。ネームサーバーからの応答は、その問合せによってなされた質問に回答するか、リクエスタに別のネームサーバーの集合を参照させるか、何らかのエラー状態を知らせるか、何れかになる。
</p>
<p>
<span class="original">
In general, the user does not generate queries directly, but instead
makes a request to a resolver which in turn sends one or more queries to
name servers and deals with the error conditions and referrals that may
result.  Of course, the possible questions which can be asked in a query
does shape the kind of service a resolver can provide.
</span>
  一般にユーザーは、直接問合せを生成するのではなく、代わりにリゾルバへのリクエストを生成する。リゾルバはネームサーバーにひとつ以上の問合せを送信し、結果として起こる参照やエラー状態を処理する。当然ながら、問合せできる質問がリゾルバの提供できるサービスの種類を決定する。
</p>
<p>
<span class="original">
DNS queries and responses are carried in a standard message format.  The
message format has a header containing a number of fixed fields which
are always present, and four sections which carry query parameters and
RRs.
</span>
  DNS の問合せと応答は標準メッセージフォーマットで送られる。メッセージフォーマットは、必ず提示される多くの固定フィールドを持つヘッダと、問合せパラメータおよび RR を伝える 4 つのセクションとを持つ。
</p>
<p>
<a name="INDEX-INVERSEQUERIES"></a><a name="INDEX-OPCODE"></a>
<span class="original">
The most important field in the header is a four bit field called an
opcode which separates different queries.  Of the possible 16 values,
one (standard query) is part of the official protocol, two (inverse
query and status query) are options, one (completion) is obsolete, and
the rest are unassigned.
</span>
  ヘッダ内でもっとも重要なフィールドは opcode と呼ばれる 4 ビットのフィールドで、種々の問合せを区別するものである。取り得る 16 の値のうち、ひとつ(標準問合せ)は公式なプロトコルの一部であり、二つ(逆問合せと状態問合せ)はオプション、ひとつ(補完(completion))は非推奨、その他は未割当てである。
</p>
<p>
<a name="INDEX-SECTIONS"></a>
<span class="original">
The four sections are:
</span>
  4 つのセクションは以下の通り：
</p>
<dl>
  <dt>
    <span class="original">
    Question(質問)
    </span>
  </dt>
  <dd>
    <span class="original">
    Carries the query name and other query parameters.
    </span>
    問合せる名前とその他の問合せパラメータとを伝える。
  </dd>
  
  <dt>
    <span class="original">
    Answer(回答)
    </span>
  </dt>
  <dd>
    <span class="original">
    Carries RRs which directly answer the query.
    </span>
    問合せの直接の回答となる RR を伝える。
  </dd>
  
  <dt>
    <span class="original">
    Authority(権威)
    </span>
  </dt>
  <dd>
    <span class="original">
    Carries RRs which describe other authoritative servers.
    May optionally carry the SOA RR for the authoritative
    data in the answer section.
    </span>
    別の権威サーバーを記述する RR を伝える。任意で Answer セクション内の権威情報の SOA RR を伝えることもできる。
  </dd>
  
  <dt>
    <span class="original">
    Additional(追加)
    </span>
  </dt>
  <dd>
    <span class="original">
    Carries RRs which may be helpful in using the RRs in the
    other sections.
    </span>
    別セクション内の RR を使用する際に参考になる RR を伝える。
  </dd>
</dl>
<p>
<span class="original">
Note that the content, but not the format, of these sections varies with
header opcode.
</span>
  ヘッダの opcode によって変化するのはこれらのセクションの内容であり、フォーマットではないことに注意してほしい。
</p>

<h4>
<a name="INDEX-STANDARDQUERIES"></a>
<span class="original">
3.7.1. Standard queries
</span>
3.7.1. 標準問合せ
</h4>

<p>
<a name="INDEX-QCLASS"></a><a name="INDEX-QTYPE"></a>
<span class="original">
A standard query specifies a target domain name (QNAME), query type
(QTYPE), and query class (QCLASS) and asks for RRs which match.  This
type of query makes up such a vast majority of DNS queries that we use
the term "query" to mean standard query unless otherwise specified.  The
QTYPE and QCLASS fields are each 16 bits long, and are a superset of
defined types and classes.
</span>
  標準問合せは、目的のドメイン名(QNAME)・問合せタイプ(QTYPE)・問合せクラス(QCLASS)を指定し、それに一致する RR を求める。DNS の問合せの大多数はこの種類であるため、私たちは特に断らない限り "問合せ(query)" という用語をこの標準問合せを意味するものとして使用する。QTYPE フィールドおよび QCLASS フィールドは共に 16 ビット長で、定義済みのタイプおよびクラスの上位集合である。
</p>
<p>
<span class="original">
The QTYPE field may contain:
</span>
  QTYPE フィールドは以下の内容を含むことができる：
</p>
<dl>
  <dt>
    <span class="original">
    &lt;any type&gt;
    </span>
    &lt;任意のタイプ&gt;
  </dt>
  <dd>
    <span class="original">
    matches just that type. (e.g., A, PTR).
    </span>
    そのタイプ(例えば A、PTR)にのみ一致する。
  </dd>
  
  <dt><a name="INDEX-AXFR"></a>AXFR</dt>
  <dd>
    <span class="original">
    special zone transfer QTYPE.
    </span>
    特別なゾーン転送 QTYPE。
  </dd>
  
  <dt>MAILB</dt>
  <dd>
    <span class="original">
    matches all mail box related RRs (e.g. MB and MG).
    </span>
    メールボックスに関連するすべての RR (例えば MB と MG)に一致する。
  </dd>
  
  <dt>*</dt>
  <dd>
    <span class="original">
    matches all RR types.
    </span>
    すべての RR タイプに一致する。
  </dd>
</dl>
<p>
<span class="original">
The QCLASS field may contain:
</span>
  QCLASS フィールドは以下の内容を含むことができる：
</p>
<dl>
  <dt>
    <span class="original">
    &lt;any class&gt;
    </span>
    &lt;任意のクラス&gt;
    </dt>
  <dd>
    <span class="original">
    matches just that class (e.g., IN, CH).
    </span>
    そのクラス(例えば IN、CH)にのみ一致する。
  </dd>
  
  <dt>*</dt>
  <dd>
    <span class="original">
    matches aLL RR classes.
    </span>
    すべての RR クラスに一致する。
  </dd>
</dl>
<p>
<a name="INDEX-NAMESERVERS2"></a>
<span class="original">
Using the query domain name, QTYPE, and QCLASS, the name server looks
for matching RRs.  In addition to relevant records, the name server may
return RRs that point toward a name server that has the desired
information or RRs that are expected to be useful in interpreting the
relevant RRs.  For example, a name server that doesn't have the
requested information may know a name server that does; a name server
that returns a domain name in a relevant RR may also return the RR that
binds that domain name to an address.
</span>
  問合せドメイン名と QTYPE と QCLASS とを使用して、ネームサーバーはそれらに一致する RR を探す。ネームサーバーは関連するレコードに加えて、目的の情報を持つネームサーバーを指し示す RR を返したり、関連する RR を解釈するのに役立つと思われる RR を返したりしてよい。例えば、要求された情報を持っていないネームサーバーがその情報を持っているネームサーバーを知っているかもしれないし、関連する RR としてドメイン名を返すネームサーバーが、そのドメイン名とアドレスとを関連付ける RR を返すかもしれない。
</p>
<p>
<span class="original">
For example, a mailer tying to send mail to Mockapetris@ISI.EDU might
ask the resolver for mail information about ISI.EDU, resulting in a
query for QNAME=ISI.EDU, QTYPE=MX, QCLASS=IN.  The response's answer
section would be:
</span>
  例えば、Mockapetris@ISI.EDU 宛てにメールを送ろうとするメーラーは、ISI.EDU に関するメール情報をリゾルバに質問し、その結果として QNAME=ISI.EDU, QTYPE=MX, QCLASS=IN の問合せが発生する。その応答の Answer セクションは以下のようになるだろう：
</p>
<pre>    ISI.EDU.        MX      10 VENERA.ISI.EDU.
                    MX      10 VAXA.ISI.EDU.
</pre>
<p>
<span class="original">
while the additional section might be:
</span>
  一方、Additional セクションは以下のようになるだろう：
</p>
<pre>    VAXA.ISI.EDU.   A       10.2.0.27
                    A       128.9.0.33
    VENERA.ISI.EDU. A       10.1.0.52
                    A       128.9.0.32
</pre>
<p>
<span class="original">
Because the server assumes that if the requester wants mail exchange
information, it will probably want the addresses of the mail exchanges
soon afterward.
</span>
  なぜならサーバーは、リクエスタがメールエクスチェンジ情報を要求した場合、その後すぐにそのメールエクスチェンジのアドレスを要求するであろうと仮定するためである。
</p>
<p>
<span class="original">
Note that the QCLASS=* construct requires special interpretation
regarding authority.  Since a particular name server may not know all of
the classes available in the domain system, it can never know if it is
authoritative for all classes.  Hence responses to QCLASS=* queries can
never be authoritative.
</span>
  QCLASS=* の構成は、権威に関連して特別な解釈を必要とすることに注意してほしい。ある特定のネームサーバーがそのドメイン組織内で有効なすべてのクラスを知っている必要はないため、サーバーは自身がすべてのクラスに対して権威を持つかどうかを決して知ることはない。したがって QCLASS=* への応答は、決して権威を持つことがない。
</p>

<h4>
<span class="original">
3.7.2. Inverse queries (Optional)
</span>
3.7.2. 逆問合せ(オプション)
</h4>

<p>
<span class="original">
Name servers may also support inverse queries that map a particular
resource to a domain name or domain names that have that resource.  For
example, while a standard query might map a domain name to a SOA RR, the
corresponding inverse query might map the SOA RR back to the domain
name.
</span>
  ネームサーバーは、ある特定のリソースを、そのリソースを持つひとつまたは複数のドメイン名にマップする逆問合せをサポートすることもできる。例えば、標準問合せはドメイン名を SOA RR にマップする一方で、それに対応する逆問合せは、その SOA RR をそのドメイン名にマップする。
</p>
<p>
<span class="original">
Implementation of this service is optional in a name server, but all
name servers must at least be able to understand an inverse query
message and return a not-implemented error response.
</span>
  ネームサーバーがこのサービスを実装するかどうかは任意だが、すべてのネームサーバーは、少なくとも逆問合せのメッセージを理解し、実装されていない旨のエラー応答を返すことが出来なければならない。
</p>
<p>
<span class="original">
The domain system cannot guarantee the completeness or uniqueness of
inverse queries because the domain system is organized by domain name
rather than by host address or any other resource type.  Inverse queries
are primarily useful for debugging and database maintenance activities.
</span>
  ドメインシステムは逆問合せの完全性や一意性を保証できない。なぜなら、ドメインシステムはホストアドレスまたは他のリソースタイプではなく、ドメイン名によって組織化されるためである。逆問合せは、デバッグおよびデータベースのメンテナンス作業において特に有効である。
</p>
<p>
<span class="original">
Inverse queries may not return the proper TTL, and do not indicate cases
where the identified RR is one of a set (for example, one address for a
host having multiple addresses).  Therefore, the RRs returned in inverse
queries should never be cached.
</span>
  逆問合せは適切な TTL を返さなくてもよく、特定された RR が集合の中のひとつ(例えば、複数のアドレスを持つホストに対するひとつのアドレス)であるような場合には提示されることもない。したがって、逆問合せで返される RR は決してキャッシュされるべきではない。
</p>
<p>
<span class="original">
Inverse queries are NOT an acceptable method for mapping host addresses
to host names; use the IN-ADDR.ARPA domain instead.
</span>
  ホストアドレスをホスト名にマッピングする方法としては、逆問合せは受け入れられるものではない。代わりに IN-ADDR.ARPA ドメインを使用する。
</p>
<p>
<span class="original">
A detailed discussion of inverse queries is contained in [RFC-1035].
</span>
  逆問合せに付いての詳細な議論は [RFC-1035] に含まれている。
</p>

<h3>
<a name="INDEX-STATUSQUERIES"></a>
<span class="original">
3.8. Status queries (Experimental)
</span>
3.8. 状態問合せ(実験目的)
</h3>

<p>
<span class="original">
To be defined.
</span>
  将来定義される。
</p>

<h3>
<a name="INDEX-COMPLETIONQUERIES"></a>
<span class="original">
3.9. Completion queries (Obsolete)
</span>
3.9. 補完問合せ(非推奨)
</h3>

<p>
<span class="original">
The optional completion services described in RFCs 882 and 883 have been
deleted.  Redesigned services may become available in the future, or the
opcodes may be reclaimed for other use.
</span>
  RFC 882 および RFC 883 で説明されているオプションの補完サービスは削除された。将来、再設計されたサービスが利用可能になってもよいし、この opcode が別の用途のために再利用されてもよい。
</p>

<h2>
<span class="original">
4. NAME SERVERS
</span>
4. ネームサーバー
</h2>

<h3>
<span class="original">
4.1. Introduction
</span>
4.1. 導入
</h3>

<p>
<a name="INDEX-ZONES"></a>
<span class="original">
Name servers are the repositories of information that make up the domain
database.  The database is divided up into sections called zones, which
are distributed among the name servers.  While name servers can have
several optional functions and sources of data, the essential task of a
name server is to answer queries using data in its zones.  By design,
name servers can answer queries in a simple manner; the response can
always be generated using only local data, and either contains the
answer to the question or a referral to other name servers "closer" to
the desired information.
</span>
  ネームサーバーはドメインデータベースを形成する情報の保管場所である。データベースはゾーンと呼ばれる部分に分割され、ネームサーバー間に分散される。ネームサーバーはいくつかのオプションの機能とデータソースとを持つことができる一方、ネームサーバーの必須の仕事はそのゾーン内の情報を使用して問合せに答えることである。設計上、ネームサーバーは単純な法則にしたがって問合せに答えることができる。その応答は常にローカルの情報だけを使用して生成され、質問への答えか、目的の情報に "より近い(closer)" 他のネームサーバーへの参照かを返す。
</p>
<p>
<span class="original">
A given zone will be available from several name servers to insure its
availability in spite of host or communication link failure.  By
administrative fiat, we require every zone to be available on at least
two servers, and many zones have more redundancy than that.
</span>
  ある特定のゾーンは、ホストや通信回線の故障時でも利用できることを保証するために、複数のネームサーバーから利用可能だろう。管理上の判断により、私たちは全てのゾーンが少なくとも二つのサーバー上で利用可能であること、大部分のゾーンはそれ以上の冗長性を持つことを要求する。
</p>
<p>
<span class="original">
A given name server will typically support one or more zones, but this
gives it authoritative information about only a small section of the
domain tree.  It may also have some cached non-authoritative data about
other parts of the tree.  The name server marks its responses to queries
so that the requester can tell whether the response comes from
authoritative data or not.
</span>
  ある特定のネームサーバーは一般にひとつ以上のゾーンをサポートするが、それはドメインツリーのある小さな部分のみに関する権威情報を提供するだけである。またサーバーは、ツリーの別の部分に関する権威を持たないキャッシュされた情報を持つことができる。ネームサーバーは、その応答が権威情報から来たものかどうかをリクエスタが答えられるように、問合せへの応答に印を付ける。
</p>

<h3>
<span class="original">
4.2. How the database is divided into zones
</span>
4.2. データベースをゾーンに分割する方法
</h3>

<p>
<span class="original">
The domain database is partitioned in two ways: by class, and by "cuts"
made in the name space between nodes.
</span>
  ドメインデータベースは二つの方法で分割される: クラスによる方法と、ノード間の名前空間に "切れ目(cuts)" を作る方法である。
</p>
<p>
<span class="original">
The class partition is simple.  The database for any class is organized,
delegated, and maintained separately from all other classes.  Since, by
convention, the name spaces are the same for all classes, the separate
classes can be thought of as an array of parallel namespace trees.  Note
that the data attached to nodes will be different for these different
parallel classes.  The most common reasons for creating a new class are
the necessity for a new data format for existing types or a desire for a
separately managed version of the existing name space.
</span>
  クラス分割は単純である。どのクラスのデータベースも他のクラスとは独立にまとめられ、委任され、保守される。習慣的に名前空間はすべてのクラスに対して同等であるので、それぞれのクラスを並列する名前空間ツリーと考えることができる。ノードに関連付けられる情報は、これら異なるクラスに対して異なるであろう点に注意してほしい。新しいクラスを作り出すもっとも一般的な理由は、既存のタイプのための新しいデータフォーマットの必要性、または既存の名前空間の独立して管理されるバージョンの要求である。
</p>
<p>
<span class="original">
Within a class, "cuts" in the name space can be made between any two
adjacent nodes.  After all cuts are made, each group of connected name
space is a separate zone.  The zone is said to be authoritative for all
names in the connected region.  Note that the "cuts" in the name space
may be in different places for different classes, the name servers may
be different, etc.
</span>
  クラス内では、その名前空間内の "切れ目(cuts)" を任意の隣接ノード間に作成することができる。すべての切れ目が作成された後、関連する名前空間の各グループは独立したゾーンとなる。そのゾーンは関連する範囲内のすべての名前に対して権威を持つと言われる。名前空間内の "切れ目(cuts)" は異なるクラスに対しては異なる場所にあってもよいこと、ネームサーバーが異なってもよいこと等に注意してほしい。
</p>
<p>
<span class="original">
These rules mean that every zone has at least one node, and hence domain
name, for which it is authoritative, and all of the nodes in a
particular zone are connected.  Given, the tree structure, every zone
has a highest node which is closer to the root than any other node in
the zone.  The name of this node is often used to identify the zone.
</span>
  これらの規則は、各ゾーンが少なくともひとつのノードを持ち、したがって、権威を持つドメイン名と特定ゾーン内の全てのノードとが関連付けられることを意味する。ツリー構造が与えられるため、各ゾーンはそのゾーン内の他のノードよりもルートに近い最上位のノードを持つ。そのノードの名前は、しばしばそのゾーンを識別するために使用される。
</p>
<p>
<span class="original">
It would be possible, though not particularly useful, to partition the
name space so that each domain name was in a separate zone or so that
all nodes were in a single zone.  Instead, the database is partitioned
at points where a particular organization wants to take over control of
a subtree.  Once an organization controls its own zone it can
unilaterally change the data in the zone, grow new tree sections
connected to the zone, delete existing nodes, or delegate new subzones
under its zone.
</span>
  各ドメイン名をそれぞれ別のゾーン内に含めたり、すべてのノードを単一のゾーンに含めたりするように名前空間を分割することも可能だが、特に役に立たないだろう。その代わりデータベースは、個々の組織がひとつのサブツリーを占有したいだろうという観点から分割される。ある組織が自身の所有するゾーンをいったん占有すると、その組織はそのゾーン内の情報を一方的に変更したり、そのゾーンに接続する新しいツリーを発展させたり、既存ノードを削除したり、そのゾーンの下に新しいゾーンを委譲したりすることができる。
</p>
<p>
<span class="original">
If the organization has substructure, it may want to make further
internal partitions to achieve nested delegations of name space control.
In some cases, such divisions are made purely to make database
maintenance more convenient.
</span>
  もし組織が下部構造を持っているなら、名前空間の制御のネストした委譲を実現するために、内部的にさらに分割したいと望むかもしれない。場合によっては、単純にデータベースのメンテナンスを行いやすくするために、そのような分割が行われる。
</p>

<h4>
<span class="original">
4.2.1. Technical considerations
</span>
4.2.1. 技術的考察
</h4>

<p>
<span class="original">
The data that describes a zone has four major parts:
</span>
  ゾーンを記述する情報は 4 つの主要な要素を持つ：
</p>
<ul>
  <li>
    <span class="original">
   - Authoritative data for all nodes within the zone.
    </span>
    そのゾーン内の全ノードのための権威情報。
  </li>
  <li>
    <span class="original">
   - Data that defines the top node of the zone (can be thought of
     as part of the authoritative data).
    </span>
    そのゾーンのトップノードを定義する情報(権威情報の一部と見なすことができる)。
  </li>
  <li>
    <span class="original">
   - Data that describes delegated subzones, i.e., cuts around the
     bottom of the zone.
    </span>
    委譲される下位ゾーン(すなわち、そのゾーンの下位の断片(cuts))を記述する情報。
  </li>
  <li>
    <a name="INDEX-GLUERRS"></a>
    <span class="original">
   - Data that allows access to name servers for subzones
     (sometimes called "glue" data).
    </span>
    サブゾーンのネームサーバーへのアクセスを可能にする情報(時に "グルー(glue)" 情報と呼ばれる)。
  </li>
</ul>
<p>
<span class="original">
All of this data is expressed in the form of RRs, so a zone can be
completely described in terms of a set of RRs.  Whole zones can be
transferred between name servers by transferring the RRs, either carried
in a series of messages or by FTPing a master file which is a textual
representation.
</span>
  これらすべての情報は RR 形式で表現される。したがって、ゾーンは RR の集合によって完全に記述することができる。すべてのゾーンは、一連のメッセージとして転送するか、テキスト形式のマスターファイルを FTP で送受信するか、どちらかの方法による RR の転送によってネームサーバー間を転送される。
</p>
<p>
<span class="original">
The authoritative data for a zone is simply all of the RRs attached to
all of the nodes from the top node of the zone down to leaf nodes or
nodes above cuts around the bottom edge of the zone.
</span>
  あるゾーンのための権威情報は、単にそのゾーンのトップノードから、末端ノードまたはそのゾーンの下位断片(cuts)の上位ノードまでの、すべてのノードに結びつくすべての RR である。
</p>
<p>
<span class="original">
Though logically part of the authoritative data, the RRs that describe
the top node of the zone are especially important to the zone's
management.  These RRs are of two types: name server RRs that list, one
per RR, all of the servers for the zone, and a single SOA RR that
describes zone management parameters.
</span>
  権威情報の論理部分ではあるが、ゾーンのトップノードを記述する RR はそのゾーンの管理のために特に重要である。これらの RR には二種類が存在する：ゾーンのすべてのサーバーを(RR ごとにひとつ)リストするネームサーバー RR と、ゾーン管理パラメータを記述するひとつの SOA RR である。
</p>
<p>
<span class="original">
The RRs that describe cuts around the bottom of the zone are NS RRs that
name the servers for the subzones.  Since the cuts are between nodes,
these RRs are NOT part of the authoritative data of the zone, and should
be exactly the same as the corresponding RRs in the top node of the
subzone.  Since name servers are always associated with zone boundaries,
NS RRs are only found at nodes which are the top node of some zone.  In
the data that makes up a zone, NS RRs are found at the top node of the
zone (and are authoritative) and at cuts around the bottom of the zone
(where they are not authoritative), but never in between.
</span>
  ゾーンの下位の断片(cuts)を記述する RR は、その下位ゾーンのためのサーバーを指名する NS RR である。断片(cuts)はノードの間にあるため、これらの RR はそのゾーンの権威情報の一部ではなく、その下位ゾーンのトップノード内の対応する RR と正確に一致するべきである。ネームサーバーは常にゾーン境界に対応するため、NS RR はゾーンのトップノードであるノードにおいてのみ見つけられる。ゾーンを構成する情報において、NS RR はそのゾーンのトップノード(それらは権威を持つ)とそのゾーンの下位の断片(cuts)(それらは権威を持たない)とに見つけられるが、その間に見つかることはない。
</p>
<p>
<span class="original">
One of the goals of the zone structure is that any zone have all the
data required to set up communications with the name servers for any
subzones.  That is, parent zones have all the information needed to
access servers for their children zones.  The NS RRs that name the
servers for subzones are often not enough for this task since they name
the servers, but do not give their addresses.  In particular, if the
name of the name server is itself in the subzone, we could be faced with
the situation where the NS RRs tell us that in order to learn a name
server's address, we should contact the server using the address we wish
to learn.  To fix this problem, a zone contains "glue" RRs which are not
part of the authoritative data, and are address RRs for the servers.
These RRs are only necessary if the name server's name is "below" the
cut, and are only used as part of a referral response.
</span>
  ゾーン構造の目的のひとつは、すべてのゾーンが、そのすべての下位ゾーンのネームサーバーと通信するために必要とされるすべての情報を持つというものである。つまり親ゾーンが、その子ゾーンのサーバーにアクセスすために必要とされるすべての情報を持つということである。下位ゾーンのサーバーを指定する NS RR はこの目的に十分ではない。なぜなら、それはサーバーを指名するが、アドレスを提示しないためである。具体的に言うと、ネームサーバーの名前自体がそのサブゾーン内にある場合、NS RR からネームサーバーのアドレスを知るには、その知りたいアドレスを使ってサーバーとコンタクトをとらなければならないという状況が起こりうる。ゾーンはこの問題を解決するために、権威情報の一部ではなく、かつそのサーバーのためのアドレス RR である "グルー(glue)" RR を含む。これらの RR は、そのネームサーバーが断片(cut)の "下位(below)" にある場合にのみ必要とされ、参照応答の一部としてのみ使用される。
</p>

<h4>
<span class="original">
4.2.2. Administrative considerations
</span>
4.2.2. 管理上の考慮事項
</h4>

<p>
<span class="original">
When some organization wants to control its own domain, the first step
is to identify the proper parent zone, and get the parent zone's owners
to agree to the delegation of control.  While there are no particular
technical constraints dealing with where in the tree this can be done,
there are some administrative groupings discussed in [RFC-1032] which
deal with top level organization, and middle level zones are free to
create their own rules.  For example, one university might choose to use
a single zone, while another might choose to organize by subzones
dedicated to individual departments or schools.  [RFC-1033] catalogs
available DNS software an discusses administration procedures.
</span>
  ある組織が独自ドメインの管理を望む場合、その第一歩は、適切な親ゾーンを特定し、その親ゾーンの所有者から管理委譲の同意を得ることである。これを行うツリー内の位置を交渉するのに技術的な制限は無いが、トップレベルの編成には [RFC-1032] で議論されている管理上のグループ分けが存在し、中間レベルのゾーンは自由に独自の規則を作成できる。例えば、ある大学は単一のゾーンを使用することを選択し、一方で別の大学は個々の学部や学科のために設けられたサブゾーンによって組織化することを選択してもよい。[RFC-1033] は、利用可能な DNS ソフトウェアと管理手続きとを列記している。
</p>
<p>
<span class="original">
Once the proper name for the new subzone is selected, the new owners
should be required to demonstrate redundant name server support.  Note
that there is no requirement that the servers for a zone reside in a
host which has a name in that domain.  In many cases, a zone will be
more accessible to the internet at large if its servers are widely
distributed rather than being within the physical facilities controlled
by the same organization that manages the zone.  For example, in the
current DNS, one of the name servers for the United Kingdom, or UK
domain, is found in the US.  This allows US hosts to get UK data without
using limited transatlantic bandwidth.
</span>
  新しいサブゾーンのための適切な名前が選択さた時点で、その新しい所有者は、冗長なネームサーバーのサポートを明らかにすることを要求されるべきである。あるゾーンのためのサーバーが、そのドメイン内に名前を持つホスト上に存在する必要はないことに注意してほしい。あるゾーンのサーバーがそのゾーンを管理する同じ組織によって管理される物理的な施設内にある場合よりも、広く分散された場合の方が、インターネットへのより広範囲のアクセス性を持つだろう。例えば今現在の DNS において、英国または UK ドメインのためのネームサーバーのひとつは、アメリカ合衆国内にある。これによりアメリカ合衆国のホストは、大西洋を横断する限られた帯域を使用することなく、UK ドメインの情報を取得することができる。
</p>
<p>
<span class="original">
As the last installation step, the delegation NS RRs and glue RRs
necessary to make the delegation effective should be added to the parent
zone.  The administrators of both zones should insure that the NS and
glue RRs which mark both sides of the cut are consistent and remain so.
</span>
  導入の最終段階として、委譲を有効にするために必要な委譲 NS RR とグルー RR とを親ゾーンに追加しなければならない。両ゾーンの管理者は、その断片(cut)の両サイドを記録する NS と グルー RR とが一貫性を持ち続けることを保証しなければならない。
</p>

<h3>
<span class="original">
4.3. Name server internals
</span>
4.3. ネームサーバー内部
</h3>

<h4>
<span class="original">
4.3.1. Queries and responses
</span>
4.3.1. 問合せと応答
</h4>

<p>
<span class="original">
The principal activity of name servers is to answer standard queries.
Both the query and its response are carried in a standard message format
which is described in [RFC-1035].  The query contains a QTYPE, QCLASS,
and QNAME, which describe the types and classes of desired information
and the name of interest.
</span>
  ネームサーバーの主要な働きは、標準問合せに答えることである。問合せとその応答とは共に、[RFC-1035] で説明されている標準メッセージフォーマットで転送される。問合せは QTYPE・QCLASS・QNAME を含み、それぞれ目的とする情報のタイプ、クラス、関心を持っている名前を表す。
</p>
<p>
<span class="original">
The way that the name server answers the query depends upon whether it
is operating in recursive mode or not:
</span>
  ネームサーバーが問合せに答える方法は、それが再帰モードで動作しているかどうかに依存する：
</p>
<ul>
  <li>
    <span class="original">
   - The simplest mode for the server is non-recursive, since it
     can answer queries using only local information: the response
     contains an error, the answer, or a referral to some other
     server "closer" to the answer.  All name servers must
     implement non-recursive queries.
    </span>
    サーバーにとってもっとも単純なモードは非再帰モードであり、その場合サーバーは、ローカルの情報のみを使用して問合せに答えることができる。応答はエラーか回答、または回答に "より近い(closer)" 他のサーバーへの参照となる。すべてのネームサーバーは、非再帰問合せを実装しなければならない。
  </li>
  <li>
    <span class="original">
   - The simplest mode for the client is recursive, since in this
     mode the name server acts in the role of a resolver and
     returns either an error or the answer, but never referrals.
     This service is optional in a name server, and the name server
     may also choose to restrict the clients which can use
     recursive mode.
    </span>
    クライアントにとってもっとも単純なモードは再帰モードであり、その場合ネームサーバーはリゾルバの役割を果たし、エラーか回答かを返すが、参照を返すことはない。ネームサーバーにおいてこのサービスはオプションであり、またネームサーバーは再帰モードを使用するクライアントを制限してもよい。
  </li>
</ul>
<p>
<a name="INDEX-RECURSIVESERVICE"></a>
<span class="original">
Recursive service is helpful in several situations:
</span>
  再帰サービスはさまざまな状況で役に立つ：
</p>
<ul>
  <li>
    <span class="original">
   - a relatively simple requester that lacks the ability to use
     anything other than a direct answer to the question.
    </span>
    問合せに対する直接の回答以外を使用する能力のない比較的単純なリクエスタ。
  </li>
  <li>
    <span class="original">
   - a request that needs to cross protocol or other boundaries and
     can be sent to a server which can act as intermediary.
    </span>
    プロトコルまたは他の境界を越える必要があり、仲介として動作することのできるサーバーに送信可能なリクエスト。
  </li>
  <li>
    <span class="original">
   - a network where we want to concentrate the cache rather than
     having a separate cache for each client.
    </span>
    各クライアントごとに個別のキャッシュを持つのではなく、キャッシュを一箇所に集中させることを望むネットワーク。
  </li>
</ul>
<p>
<span class="original">
Non-recursive service is appropriate if the requester is capable of
pursuing referrals and interested in information which will aid future
requests.
</span>
  リクエスタが参照を追跡する能力を持ち、今後のリクエストの手助けとなる情報に関心がある場合、非再帰サービスが適切である。
</p>
<p>
<span class="original">
The use of recursive mode is limited to cases where both the client and
the name server agree to its use.  The agreement is negotiated through
the use of two bits in query and response messages:
</span>
  再帰モードの使用は、クライアントとネームサーバーとが共に合意した場合に限られる。この合意は、問合せメッセージと応答メッセージとにおける二つのビットを通して交渉される：
</p>
<ul>
  <li>
    <span class="original">
   - The recursion available, or RA bit, is set or cleared by a
     name server in all responses.  The bit is true if the name
     server is willing to provide recursive service for the client,
     regardless of whether the client requested recursive service.
     That is, RA signals availability rather than use.
    </span>
    再帰有効(recursion available)(RA ビット)は、すべての応答において、ネームサーバーによってセットまたはクリアされる。このビットはクライアントが再帰サービスを要求したかどうかに関係なく、ネームサーバーがクライアントに再帰サービスを提供する意思があれば真となる。つまり RA は、使用するかどうかではなく、有効かどうかを表すものということである。
  </li>
  <li>
    <span class="original">
   - Queries contain a bit called recursion desired or RD.  This
     bit specifies whether the requester wants recursive
     service for this query.  Clients may request recursive service
     from any name server, though they should depend upon receiving
     it only from servers which have previously sent an RA, or
     servers which have agreed to provide service through private
     agreement or some other means outside of the DNS protocol.
    </span>
    問合せには、再帰要望(recursion desired)または RD と呼ばれるビットが含まれる。このビットは、リクエスタがその問合せで再帰サービスを望むかどうかを表す。クライアントは任意のネームサーバーに再帰サービスを要求してよいが、以前に RA を送信してきたサーバー、または、プライベートな取り決めか DNS プロトコル外部の手段かを通して再帰サービスの提供に合意したサーバーからのみ、そのサービスを受けられはずである。
  </li>
</ul>
<p>
<span class="original">
The recursive mode occurs when a query with RD set arrives at a server
which is willing to provide recursive service; the client can verify
that recursive mode was used by checking that both RA and RD are set in
the reply.  Note that the name server should never perform recursive
service unless asked via RD, since this interferes with trouble shooting
of name servers and their databases.
</span>
  RD をセットされた問合せが再帰サービスを提供する意思のあるサーバーに到着したとき、再帰モードが発動する。クライアントは、応答の RA と RD とが両方セットされているのを確認することで、再帰モードが使用されたことを確認できる。RD によって問い合わせられない限り、ネームサーバーは再帰サービスを実行するべきではない。なぜなら、ネームサーバーとそのデータベースとのトラブルシューティングを妨げるためである。
</p>
<p>
<span class="original">
If recursive service is requested and available, the recursive response
to a query will be one of the following:
</span>
  再帰サービスが要求され、かつ有効である場合、問合せに対する再帰応答は以下の何れかとなる：
</p>
<ul>
  <li>
    <span class="original">
   - The answer to the query, possibly preface by one or more CNAME
     RRs that specify aliases encountered on the way to an answer.
    </span>
    その問合せに対する回答。場合によっては、回答までの途中のエイリアスを特定するひとつ以上の CNAME RR が前に置かれる。
  </li>
  <li>
    <span class="original">
   - A name error indicating that the name does not exist.  This
     may include CNAME RRs that indicate that the original query
     name was an alias for a name which does not exist.
    </span>
    その名前が存在しないことを表すエラー。元の問合せ名が存在しない名前のエイリアスであったことを表す CNAME RR を含んでもよい。
  </li>
  <li>
    <span class="original">
   - A temporary error indication.
    </span>
    一時的エラー。
  </li>
</ul>
<p>
<span class="original">
If recursive service is not requested or is not available, the non-
recursive response will be one of the following:
</span>
  再帰サービスが要求されなかったか、有効でなかった場合、非再帰応答は以下の何れかとなる：
</p>
<ul>
  <li>
    <span class="original">
   - An authoritative name error indicating that the name does not
     exist.
    </span>
    その名前が存在しないことを表す権威ある名前エラー。
  </li>
  <li>
    <span class="original">
   - A temporary error indication.
    </span>
    一時的エラー。
  </li>
  <li>
    <span class="original">
   - Some combination of:
    </span>
    以下の何らかの組み合わせ：
    <p class="nomargin">
    <span class="original">
     RRs that answer the question, together with an indication
     whether the data comes from a zone or is cached.
    </span>
      質問に答える RR。その情報がゾーンから来たものか、キャッシュなのかを表す指標を伴なう。
    </p>
    <p class="nomargin">
    <span class="original">
     A referral to name servers which have zones which are closer
     ancestors to the name than the server sending the reply.
    </span>
      回答を送信したサーバーよりも、その名前に近い上位ゾーンを持つネームサーバーへの参照。
    </p>
  </li>
  <li>
    <span class="original">
   - RRs that the name server thinks will prove useful to the
     requester.
    </span>
    ネームサーバーがリクエスタにとって有用であろうと考える RR。
  </li>
</ul>

<h4>
<span class="original">
4.3.2. Algorithm
</span>
4.3.2. アルゴリズム
</h4>

<p>
<span class="original">
The actual algorithm used by the name server will depend on the local OS
and data structures used to store RRs.  The following algorithm assumes
that the RRs are organized in several tree structures, one for each
zone, and another for the cache:
</span>
  ネームサーバーが実際に使用するアルゴリズムは、ローカル OS と RR を保存するために使用するデータ構造とに依存するだろう。以下のアルゴリズムは、RR がいくつかのツリー構造(ひとつは各ゾーンのため、もうひとつはキャッシュのため)で編成されていると仮定している：
</p>
<ul>
  <li>
    <span class="original">
   1. Set or clear the value of recursion available in the response
      depending on whether the name server is willing to provide
      recursive service.  If recursive service is available and
      requested via the RD bit in the query, go to step 5,
      otherwise step 2.
    </span>
    1. ネームサーバーが再帰サービスを提供する意思があるかどうかに応じて、応答内の再帰有効ビットの値をセットまたはクリアする。再帰サービスが利用可能、かつ問合せの RD ビットによって要求されている場合、ステップ 5 へ。そうでない場合、ステップ 2 へ。
  </li>
  <li>
    <span class="original">
   2. Search the available zones for the zone which is the nearest
      ancestor to QNAME.  If such a zone is found, go to step 3,
      otherwise step 4.
    </span>
    2. QNAME の直近上位であるゾーンのために利用可能なゾーンを検索する。ゾーンが見つかった場合はステップ 3 へ、見つからなかった場合はステップ 4 へ。
  </li>
  <li>
    <span class="original">
   3. Start matching down, label by label, in the zone.  The
      matching process can terminate several ways:
    </span>
    3. そのゾーン内のラベルを順に比較する。比較は以下の条件で終了する：
    <ul class="nomargin">
    <br>
      <li>
        <span class="original">
         a. If the whole of QNAME is matched, we have found the
            node.
        </span>
        a. QNAME 全体が一致した場合、目的のノードが見つかったと言うことである。
        <p class="nomargin">
          <span class="original">
            If the data at the node is a CNAME, and QTYPE doesn't
            match CNAME, copy the CNAME RR into the answer section
            of the response, change QNAME to the canonical name in
            the CNAME RR, and go back to step 1.
          </span>
          そのノードの情報が CNAME であり、かつ QTYPE が CNAME ではない場合、応答の Answer セクションにその CNAME RR をコピーし、QNAME を CNAME RR の中の正規名に変更し、ステップ 1 に戻る。
        </p>
        <p class="nomargin">
          <span class="original">
            Otherwise, copy all RRs which match QTYPE into the
            answer section and go to step 6.
          </span>
          そうでない場合、QTYPE に一致したすべての RR を Answer セクションにコピーし、ステップ 6 に進む。
        </p>
      </li>
      <li>
        <span class="original">
         b. If a match would take us out of the authoritative data,
            we have a referral.  This happens when we encounter a
            node with NS RRs marking cuts along the bottom of a
            zone.
        </span>
          b. 一致したのが権威情報ではない場合、それは参照である。これは、ゾーンの下位の断片(cuts)を表す NS RR を持つノードに遭遇した場合に発生する。
        <p class="nomargin">
          <span class="original">
            Copy the NS RRs for the subzone into the authority
            section of the reply.  Put whatever addresses are
            available into the additional section, using glue RRs
            if the addresses are not available from authoritative
            data or the cache.  Go to step 4.
          </span>
          応答の Authority セクションに、そのサブゾーンのための NS RR をコピーする。権威情報またはキャッシュからのアドレスを使用できなければグルー RR を使用して、何であれ有効なアドレスを Additional セクションに入れる。ステップ 4 に進む。
        </p>
      </li>
      <li>
        <span class="original">
         c. If at some label, a match is impossible (i.e., the
            corresponding label does not exist), look to see if a
            the "*" label exists.
        </span>
        c. 一部のラベルで検索が不可能な場合(例えば対応するラベルが存在しない場合)、ラベル "*" が存在するかどうかを調べる。
        <p class="nomargin">
          <span class="original">
            If the "*" label does not exist, check whether the name
            we are looking for is the original QNAME in the query
            or a name we have followed due to a CNAME.  If the name
            is original, set an authoritative name error in the
            response and exit.  Otherwise just exit.
          </span>
          ラベル "*" が存在しない場合、探している名前が問合せのオリジナルのQNAME なのか、CNAME のために追跡した名前なのかを確認する。名前がオリジナルの場合、権威ある名前エラーを応答にセットして終了する。そうでない場合は単に終了する。
        </p>
        <p class="nomargin">
          <span class="original">
            If the "*" label does exist, match RRs at that node
            against QTYPE.  If any match, copy them into the answer
            section, but set the owner of the RR to be QNAME, and
            not the node with the "*" label.  Go to step 6.
          </span>
          ラベル "*" が存在する場合、そのノードの RR を QTYPE に対して一致させる。何であれ一致すれば、それらを Answer セクションにコピーする。ただし RR の所有者は、ラベル "*" を持つノードではなく、QNAME になるように設定する。ステップ 6 に進む。
        </p>
      </li>
    </ul>
  </li>
  <li>
    <span class="original">
   4. Start matching down in the cache.  If QNAME is found in the
      cache, copy all RRs attached to it that match QTYPE into the
      answer section.  If there was no delegation from
      authoritative data, look for the best one from the cache, and
      put it in the authority section.  Go to step 6.
    </span>
    4. キャッシュ内の比較を開始する。キャッシュ内に QNAME が見つかった場合、QTYPE に一致するすべての RR を Answer セクションにコピーする。権威情報からの委任がない場合、キャッシュから最良のものを探し、それを Authority セクションに置く。ステップ 6 に進む。
  </li>
  <li>
    <span class="original">
   5. Using the local resolver or a copy of its algorithm (see
      resolver section of this memo) to answer the query.  Store
      the results, including any intermediate CNAMEs, in the answer
      section of the response.
    </span>
    5. 問合せに答えるために、ローカルのリゾルバ、またはそのアルゴリズム(この文書のリゾルバのセクションを参照)のコピーを使用する。任意の中間の CNAME を含めて、応答の Answer セクションに結果を格納する。
  </li>
  <li>
    <span class="original">
   6. Using local data only, attempt to add other RRs which may be
      useful to the additional section of the query.  Exit.
    </span>
    6. ローカル情報のみを使用して、役に立つと思われる他の RR を問合せの Additional セクションに追加する。
  </li>
</ul>

<h4>
<a name="INDEX-WILDCARDS"></a>
<span class="original">
4.3.3. Wildcards
</span>
4.3.3. ワイルドカード
</h4>

<p>
<span class="original">
In the previous algorithm, special treatment was given to RRs with owner
names starting with the label "*".  Such RRs are called wildcards.
Wildcard RRs can be thought of as instructions for synthesizing RRs.
When the appropriate conditions are met, the name server creates RRs
with an owner name equal to the query name and contents taken from the
wildcard RRs.
</span>
  前述のアルゴリズムにおいて、ラベル "*" から始まる所有者名を持つ RR に対して特別な扱いをした。このような RR はワイルドカードと呼ばれる。ワイルドカード RR は、RR を合成する指示と考えることができる。適切な条件が満たされたとき、ネームサーバーは問合せ名に等しい所有者名と内容とをワイルドカード RR から取り出し、RR を生成する。
</p>
<p>
<span class="original">
This facility is most often used to create a zone which will be used to
forward mail from the Internet to some other mail system.  The general
idea is that any name in that zone which is presented to server in a
query will be assumed to exist, with certain properties, unless explicit
evidence exists to the contrary.  Note that the use of the term zone
here, instead of domain, is intentional; such defaults do not propagate
across zone boundaries, although a subzone may choose to achieve that
appearance by setting up similar defaults.
</span>
  この仕組みがもっともよく使用されるのは、インターネットからのメールを別のメールシステムに転送するためのゾーンを生成する場合である。その概念は、問合せにおいてサーバーに提示されたゾーン内の任意の名前は、明確な反証がない限り一定の属性を持って存在しているだろうということである。ここでドメインではなくゾーンという言葉を意図的に使用していることに注意してほしい。このような初期値がゾーン境界をまたがることはないが、サブゾーンが同じような初期値を設定することで同じことを実現する可能性がある。
</p>
<p>
<span class="original">
The contents of the wildcard RRs follows the usual rules and formats for
RRs.  The wildcards in the zone have an owner name that controls the
query names they will match.  The owner name of the wildcard RRs is of
the form "*.&lt;anydomain&gt;", where &lt;anydomain&gt; is any domain name.
&lt;anydomain&gt; should not contain other * labels, and should be in the
authoritative data of the zone.  The wildcards potentially apply to
descendants of &lt;anydomain&gt;, but not to &lt;anydomain&gt; itself.  Another way
to look at this is that the "*" label always matches at least one whole
label and sometimes more, but always whole labels.
</span>
  ワイルドカード RR の内容は、RR のための通常の規則とフォーマットとにしたがう。ゾーン内のワイルドカードは、一致した問合せ名を制御する所有者名を持つ。ワイルドカード RR の所有者名は "*.&lt;anydomain&gt;" の形式である(&lt;anydomain&gt; は任意のドメイン名)。&lt;anydomain&gt; は別の * を含むべきではなく、そのゾーンの権威情報内に存在するべきである。ワイルドカードは潜在的に &lt;anydomain&gt; の子孫に適用されるが、&lt;anydomain&gt; 自身には適用されない。別の見方をすると、ラベル "*" は、常に少なくともひとつ以上の完全なラベルに一致するが、常にラベル群全体に一致するということである。
</p>
<p>
<span class="original">
Wildcard RRs do not apply:
</span>
  以下の場合、ワイルドカード RR は適用されない：
</p>
<ul>
  <li>
    <span class="original">
   - When the query is in another zone.  That is, delegation cancels
     the wildcard defaults.
    </span>
    問合せが別のゾーンにある場合。つまり、委譲はワイルドカードによるデフォルトを取り消す。
  </li>
  <li>
    <span class="original">
   - When the query name or a name between the wildcard domain and
     the query name is know to exist.  For example, if a wildcard
     RR has an owner name of "*.X", and the zone also contains RRs
     attached to B.X, the wildcards would apply to queries for name
     Z.X (presuming there is no explicit information for Z.X), but
     not to B.X, A.B.X, or X.
    </span>
    問合せ名、またはワイルドカードと問合せ名との間の名前が存在していると分かっている場合。例えば、ワイルドカード RR が所有者名 "*.X" を持ち、そのゾーンが B.X に属する RR を含む場合、そのワイルドカードは名前 Z.X (Z.X のための明示的な情報は存在しないと仮定する)の問合せには適用されるが、B.X、A.B.X、X には適用されないだろう。
  </li>
</ul>
<p>
<span class="original">
A * label appearing in a query name has no special effect, but can be
used to test for wildcards in an authoritative zone; such a query is the
only way to get a response containing RRs with an owner name with * in
it.  The result of such a query should not be cached.
</span>
  問合せ名の中に現れるラベル * は特別な効果を持たないが、権威ゾーン内のワイルドカードをテストするために使用することができる。このような問合せは、所有者名に * を持つ RR を含む応答を取得する唯一の手段である。この種の問合せの結果はキャッシュされるべきではない。
</p>
<p>
<span class="original">
Note that the contents of the wildcard RRs are not modified when used to
synthesize RRs.
</span>
  RR の合成に使用されるとき、ワイルドカード RR の内容は修正されないことに注意してほしい。
</p>
<p>
<span class="original">
To illustrate the use of wildcard RRs, suppose a large company with a
large, non-IP/TCP, network wanted to create a mail gateway.  If the
company was called X.COM, and IP/TCP capable gateway machine was called
A.X.COM, the following RRs might be entered into the COM zone:
</span>
  ワイルドカード RR の使用方法を説明するために、非 IP/TCP の大きいネットワークを持つ大企業がメールゲートウェイを作成したい場合を考える。その企業を X.COM とし、IP/TCP 能力のあるゲートウェイマシンを A.X.COM とすると、以下の RR が COM ゾーンに入れられるだろう：
</p>
<pre>    X.COM           MX      10      A.X.COM

    *.X.COM         MX      10      A.X.COM

    A.X.COM         A       1.2.3.4
    A.X.COM         MX      10      A.X.COM

    *.A.X.COM       MX      10      A.X.COM
</pre>
<p>
<span class="original">
This would cause any MX query for any domain name ending in X.COM to
return an MX RR pointing at A.X.COM.  Two wildcard RRs are required
since the effect of the wildcard at *.X.COM is inhibited in the A.X.COM
subtree by the explicit data for A.X.COM.  Note also that the explicit
MX data at X.COM and A.X.COM is required, and that none of the RRs above
would match a query name of XX.COM.
</span>
  これにより、X.COM で終わるすべてのドメイン名に対する MX 問合せに対し、A.X.COM を指す MX RR が返されることになる。A.X.COM のための明示的な情報があるため、*.X.COM のワイルドカードの効果はサブツリー A.X.COM に対しては抑制される。そのため、二つのワイルドカード RR が必要となる。X.COM と A.X.COM とにおける明示的な MX 情報が必要であること、上記の RR は問合せ名 XX.COM には一致しないことに注意してほしい。
</p>

<h4>
<span class="original">
4.3.4. Negative response caching (Optional)
</span>
4.3.4. 否定応答キャッシュ(オプション)
</h4>

<p>
<a name="INDEX-NAMEERROR1"></a>
<span class="original">
The DNS provides an optional service which allows name servers to
distribute, and resolvers to cache, negative results with TTLs.  For
example, a name server can distribute a TTL along with a name error
indication, and a resolver receiving such information is allowed to
assume that the name does not exist during the TTL period without
consulting authoritative data.  Similarly, a resolver can make a query
with a QTYPE which matches multiple types, and cache the fact that some
of the types are not present.
</span>
  DNS はオプションで、TTL を持つ否定結果をネームサーバーが配布したりリゾルバがキャッシュしたりすることを許可するサービスを提供する。例えばネームサーバーは名前エラーと共に TTL を配布することが可能であり、そのような情報を受け取ったリゾルバは、その TTL の間は権威情報を確認することなくその名前が存在しないと仮定することが許される。同じように、リゾルバは複数のタイプに一致する QTYPE を持つ問合せを生成し、一部のタイプが存在しないという結果をキャッシュすることができる。
</p>
<p>
<span class="original">
This feature can be particularly important in a system which implements
naming shorthands that use search lists beacuse a popular shorthand,
which happens to require a suffix toward the end of the search list,
will generate multiple name errors whenever it is used.
</span>
  よく知られた省略形(たまたま検索リストの終わりに接尾辞を必要とする)は、使用されると常に複数のエラーを生成する。そのためこの機能は、検索リストを使用する省略形の命名を実装するシステムにおいて特に重要となり得る。
</p>
<p>
<span class="original">
The method is that a name server may add an SOA RR to the additional
section of a response when that response is authoritative.  The SOA must
be that of the zone which was the source of the authoritative data in
the answer section, or name error if applicable.  The MINIMUM field of
the SOA controls the length of time that the negative result may be
cached.
</span>
  この方法は、ネームサーバーが権威ある応答を返すとき、その応答の Authority セクションに SOA RR を追加することを許可するものである。SOA は Answer セクションの権威情報、またはネームエラーの発生源であったゾーンのものでなければならない。SOA の MINIMUM フィールドは、その否定結果をキャッシュしてよい期間を制御する。<br>
<b>(訳注：1 文目、原文では「Additional section」となっていますが、RFC 2181 にて「Authority section」と訂正されています。この翻訳ではその訂正を反映しています。)</b>
</p>
<p>
<span class="original">
Note that in some circumstances, the answer section may contain multiple
owner names.  In this case, the SOA mechanism should only be used for
the data which matches QNAME, which is the only authoritative data in
this section.
</span>
  環境によっては Answer セクションに複数の所有者名が含まれる可能性があることに注意してほしい。その場合この SOA のメカニズムは、このセクションの中の唯一の権威情報である QNAME に一致する情報のためにのみ使用されるべきである。
</p>
<p>
<span class="original">
Name servers and resolvers should never attempt to add SOAs to the
additional section of a non-authoritative response, or attempt to infer
results which are not directly stated in an authoritative response.
There are several reasons for this, including: cached information isn't
usually enough to match up RRs and their zone names, SOA RRs may be
cached due to direct SOA queries, and name servers are not required to
output the SOAs in the authority section.
</span>
  ネームサーバーとリゾルバとは、権威のない応答の Authority セクションに SOA を追加しようと試みたり、権威ある応答に直接示されていない結果を推測しようと試みたりするべきではない。これにはいくつかの理由がある：キャッシュされた情報は RR およびそのゾーン名と比較するのに十分ではないこと、SOA RR は直接の SOA 問合せによってキャッシュされる可能性があること、ネームサーバーは Authority セクションに SOA を出力することを要求されないこと。<br>
<b>(訳注：1 文目、原文では「Additional section」となっていますが、RFC 2181 にて「Authority section」と訂正されています。この翻訳ではその訂正を反映しています。)</b>
</p>
<p>
<span class="original">
This feature is optional, although a refined version is expected to
become part of the standard protocol in the future.  Name servers are
not required to add the SOA RRs in all authoritative responses, nor are
resolvers required to cache negative results.  Both are recommended.
All resolvers and recursive name servers are required to at least be
able to ignore the SOA RR when it is present in a response.
</span>
  この機能はオプションだが、将来洗練されたバージョンが標準プロトコルの一部になることが期待される。ネームサーバーは権威応答に SOA RR を追加することを要求されないし、リゾルバは否定結果をキャッシュすることを要求されない。これらは共に推奨事項である。すべてのリゾルバと再帰ネームサーバーとは、応答内に SOA RR が現れたとき、少なくともそれらを無視できることを要求される。
</p>
<p>
<span class="original">
Some experiments have also been proposed which will use this feature.
The idea is that if cached data is known to come from a particular zone,
and if an authoritative copy of the zone's SOA is obtained, and if the
zone's SERIAL has not changed since the data was cached, then the TTL of
the cached data can be reset to the zone MINIMUM value if it is smaller.
This usage is mentioned for planning purposes only, and is not
recommended as yet.
</span>
  また、この機能を使用するいくつかの実験が提案されている。その着想は、キャッシュされた情報が特定のゾーンから来たことが分かっており、かつそのゾーンの SOA の権威あるコピーを取得しており、さらにそのゾーンの SERIAL がキャッシュされてから変更されていない場合、そのキャッシュされた情報の TTL を(それがそのゾーンの MINIMUM の値より小さい場合に)そのゾーンの MINIMUM の値にリセットするというものである。この使用方法は予定として言及されているだけであり、今のところ推奨事項ではない。
</p>

<h4>
<a name="INDEX-ZONETRANSFERS"></a>
<span class="original">
4.3.5. Zone maintenance and transfers
</span>
4.3.5. ゾーンの保守と転送
</h4>

<p>
<span class="original">
Part of the job of a zone administrator is to maintain the zones at all
of the name servers which are authoritative for the zone.  When the
inevitable changes are made, they must be distributed to all of the name
servers.  While this distribution can be accomplished using FTP or some
other ad hoc procedure, the preferred method is the zone transfer part
of the DNS protocol.
</span>
  ゾーン管理者の仕事の一部は、そのゾーンに権威を持つすべてのネームサーバーの保守である。避けられない変更が行われるとき、それはすべてのネームサーバーに配布されなければならない。この配布は FTP または他の任意の方法により実現できるが、DNS プロトコルのゾーン転送による方法が好ましい。
</p>
<p>
<span class="original">
The general model of automatic zone transfer or refreshing is that one
of the name servers is the master or primary for the zone.  Changes are
coordinated at the primary, typically by editing a master file for the
zone.  After editing, the administrator signals the master server to
load the new zone.  The other non-master or secondary servers for the
zone periodically check for changes (at a selectable interval) and
obtain new zone copies when changes have been made.
</span>
  ゾーンの自動転送または自動リフレッシュの一般的モデルは、ネームサーバーのひとつがゾーンのマスターまたはプライマリになるというものである。一般に変更とはそのゾーンのマスターファイルを編集することであり、プライマリサーバー上で行われる。編集後、管理者はマスターサーバーに新しいゾーンの読み込みを指示する。他の非マスターまたはセカンダリのサーバーは変更を定期的(間隔は指定可能)に確認し、変更が行われていれば新しいゾーンのコピーを取得する。
</p>
<p>
<span class="original">
To detect changes, secondaries just check the SERIAL field of the SOA
for the zone.  In addition to whatever other changes are made, the
SERIAL field in the SOA of the zone is always advanced whenever any
change is made to the zone.  The advancing can be a simple increment, or
could be based on the write date and time of the master file, etc.  The
purpose is to make it possible to determine which of two copies of a
zone is more recent by comparing serial numbers.  Serial number advances
and comparisons use sequence space arithmetic, so there is a theoretic
limit on how fast a zone can be updated, basically that old copies must
die out before the serial number covers half of its 32 bit range.  In
practice, the only concern is that the compare operation deals properly
with comparisons around the boundary between the most positive and most
negative 32 bit numbers.
</span>
  変更を検出するために、セカンダリサーバーはそのゾーンの SOA の SERIAL フィールドのみを確認する。変更が加えられる場合、常に同時にそのゾーンの SOA の SERIAL フィールドの値が増やされる。この増加は、単純なインクリメントや、マスターファイルの書き込み日時に基づく方法で行うことができる。目的は、シリアル番号の比較によりゾーンの二つのコピーのどちらが新しいかを判断できるようにすることである。シリアル番号の増加と比較とにはシリアル番号演算が使用される。そのため、ゾーンを更新できる速さには論理的限界があり、基本的にシリアル値が 32 ビット範囲の半分を使い切る前に、古いコピーは消滅しなければならない。現実問題として唯一の懸念事項は、この比較演算が 32 ビット値の正の最大値と負の最大値との近辺の比較を適切に扱えるかどうかである。
</p>
<p>
<span class="original">
The periodic polling of the secondary servers is controlled by
parameters in the SOA RR for the zone, which set the minimum acceptable
polling intervals.  The parameters are called REFRESH, RETRY, and
EXPIRE.  Whenever a new zone is loaded in a secondary, the secondary
waits REFRESH seconds before checking with the primary for a new serial.
If this check cannot be completed, new checks are started every RETRY
seconds.  The check is a simple query to the primary for the SOA RR of
the zone.  If the serial field in the secondary's zone copy is equal to
the serial returned by the primary, then no changes have occurred, and
the REFRESH interval wait is restarted.  If the secondary finds it
impossible to perform a serial check for the EXPIRE interval, it must
assume that its copy of the zone is obsolete an discard it.
</span>
  セカンダリサーバーによる定期的なポーリングは、そのゾーンの SOA RR 内のパラメータによって制御され、そのパラメータには受け入れられる最低のポーリング間隔がセットされる。そのパラメータは REFRESH、RETRY、EXPIRE と呼ばれるものである。セカンダリに新しいゾーンが読み込まれたときにはいつでも、プライマリの新しいシリアル値を確認する前に、セカンダリは REFRESH 秒だけ待機する。確認を完了できなかった場合、新しい確認は RETRY 秒ごとに開始される。この確認は、そのゾーンの SOA RR をプライマリに求める単純な問合せである。セカンダリの持つゾーンのコピーの SERIAL フィールドがプライマリによって返されたシリアル値と同じ場合、変更は行われていないということであり、REFRESH 秒間の待機が再び開始される。EXPIRE 秒のあいだシリアル値の確認を実行できないことを検出したセカンダリは、そのゾーンのコピーがもはや使用されていないものと判断し、破棄しなければならない。
</p>
<p>
<span class="original">
When the poll shows that the zone has changed, then the secondary server
must request a zone transfer via an AXFR request for the zone.  The AXFR
may cause an error, such as refused, but normally is answered by a
sequence of response messages.  The first and last messages must contain
the data for the top authoritative node of the zone.  Intermediate
messages carry all of the other RRs from the zone, including both
authoritative and non-authoritative RRs.  The stream of messages allows
the secondary to construct a copy of the zone.  Because accuracy is
essential, TCP or some other reliable protocol must be used for AXFR
requests.
</span>
  ポーリングによりそのゾーンが変更されていることが分かった場合、セカンダリサーバーはそのゾーンに対し AXFR リクエストによるゾーン転送を要求しなければならない。最初と最後のメッセージは、そのゾーンの権威ある最上位ノードのための情報を含まなければならない。そのあいだのメッセージで、そのゾーンの他の RR (権威 RR も非権威 RR も含めて)のすべてを伝える。その一連のメッセージにより、セカンダリサーバーはそのゾーンのコピーを作成することができる。正確さが必須であるため、AXFR リクエストには TCP または他の信頼できるプロトコルを使用しなければならない。
</p>
<p>
<span class="original">
Each secondary server is required to perform the following operations
against the master, but may also optionally perform these operations
against other secondary servers.  This strategy can improve the transfer
process when the primary is unavailable due to host downtime or network
problems, or when a secondary server has better network access to an
"intermediate" secondary than to the primary.
</span>
  各セカンダリサーバーはマスターサーバーに追随する動作を要求されるが、任意で他のセカンダリサーバーに対してこれらの操作を実行してもよい。この戦略は、ホストの故障またはネットワークの問題によりプライマリを利用できない場合や、セカンダリサーバーが "中間の(intermediate)" セカンダリに対してプライマリよりも優れたネットワークアクセス性を持っている場合に、転送プロセスを改善する。
</p>

<h2>
<span class="original">
5. RESOLVERS
</span>
5. リゾルバ
</h2>

<h3>
<span class="original">
5.1. Introduction
</span>
5.1. 導入
</h3>

<p>
<span class="original">
Resolvers are programs that interface user programs to domain name
servers.  In the simplest case, a resolver receives a request from a
user program (e.g., mail programs, TELNET, FTP) in the form of a
subroutine call, system call etc., and returns the desired information
in a form compatible with the local host's data formats.
</span>
  リゾルバは、ユーザープログラムをドメインネームサーバーにインターフェイスするプログラムである。もっとも単純な場合、リゾルバはユーザープログラム(例えばメールプログラム、TELNET、FTP)からサブルーチンコールやシステムコールなどの形でリクエストを受け取り、求められた情報をローカルホストのデータフォーマットと互換性のある形式で返す。
</p>
<p>
<span class="original">
The resolver is located on the same machine as the program that requests
the resolver's services, but it may need to consult name servers on
other hosts.  Because a resolver may need to consult several name
servers, or may have the requested information in a local cache, the
amount of time that a resolver will take to complete can vary quite a
bit, from milliseconds to several seconds.
</span>
  リゾルバはサービスを要求するプログラムと同じマシン上に位置するが、他ホスト上のネームサーバーの参照を必要とする可能性がある。リゾルバは複数のネームサーバーの参照を必要としたり、要求された情報をローカルキャッシュに保持していたりする可能性があるため、リゾルバが処理を完了するのに要する時間は、数ミリ秒から数秒まで、相当に異なる可能性がある。
</p>
<p>
<span class="original">
A very important goal of the resolver is to eliminate network delay and
name server load from most requests by answering them from its cache of
prior results.  It follows that caches which are shared by multiple
processes, users, machines, etc., are more efficient than non-shared
caches.
</span>
  リゾルバの特に重要な目的は、大部分のリクエストに過去の結果のキャッシュから回答することで、ネットワークの遅延とネームサーバーの負荷とを削減することである。つまり、複数のプロセス・ユーザー・マシンなどにより共有されるキャッシュは、共有されないキャッシュよりも効率的ということである。
</p>

<h3>
<span class="original">
5.2. Client-resolver interface
</span>
5.2. クライアント-リゾルバ インターフェイス
</h3>

<h4>
<span class="original">
5.2.1. Typical functions
</span>
5.2.1. 代表的な機能
</h4>

<p>
<span class="original">
The client interface to the resolver is influenced by the local host's
conventions, but the typical resolver-client interface has three
functions:
</span>
  リゾルバに対するクライアントインターフェイスはローカルホストの習慣に影響されるが、典型的なリゾルバ-クライアントインターフェイスは三つの機能を持つ：
</p>
<ul>
  <li>
    <span class="original">
   1. Host name to host address translation.
    </span>
    1. ホスト名からホストアドレスへの変換
    <p class="nomargin">
      <span class="original">
      This function is often defined to mimic a previous HOSTS.TXT
      based function.  Given a character string, the caller wants
      one or more 32 bit IP addresses.  Under the DNS, it
      translates into a request for type A RRs.  Since the DNS does
      not preserve the order of RRs, this function may choose to
      sort the returned addresses or select the "best" address if
      the service returns only one choice to the client.  Note that
      a multiple address return is recommended, but a single
      address may be the only way to emulate prior HOSTS.TXT
      services.
      </span>
      この機能は、しばしば過去の HOSTS.TXT ベースの機能の模倣として定義される。呼び出し側は文字列を与え、ひとつまたは複数の 32 ビット IP アドレスを求める。DNS において、これはタイプ A の RR のリクエストに変換される。DNS は RR の並び順を保持しないため、この機能は返されるアドレスをソートしたり、サービスがクライアントにひとつの選択肢だけを返す場合には "最良の(best)" アドレスを選択したりする可能性がある。複数のアドレスを返すことが推奨されるが、単一のアドレスを返す方法が HOSTS.TXT を模倣する唯一の方法であることに注意してほしい。
    </p>
  </li>
  <li>
    <span class="original">
   2. Host address to host name translation
    </span>
    2. ホストアドレスからホスト名への変換
    <p class="nomargin">
      <span class="original">
      This function will often follow the form of previous
      functions.  Given a 32 bit IP address, the caller wants a
      character string.  The octets of the IP address are reversed,
      used as name components, and suffixed with "IN-ADDR.ARPA".  A
      type PTR query is used to get the RR with the primary name of
      the host.  For example, a request for the host name
      corresponding to IP address 1.2.3.4 looks for PTR RRs for
      domain name "4.3.2.1.IN-ADDR.ARPA".
      </span>
      この機能はしばしば前記の機能の形式に付随する。呼び出し側は 32 ビット IP アドレスを与え、文字列を求める。IP アドレスのオクテットは反転されたうえで名前要素として使用され、末尾に "IN-ADDR.ARPA" が置かれる。タイプ PTR の問合せは、ホストの主要な名前の RR を取得するために使用される。例えば IP アドレス 1.2.3.4 に対応するホスト名の要求は、ドメイン名 "4.3.2.1.IN-ADDR.ARPA" の PTR RR を探すものになる。
    </p>
  </li>
  <li>
    <span class="original">
   3. General lookup function
    </span>
    汎用検索機能
    <p class="nomargin">
      <span class="original">
      This function retrieves arbitrary information from the DNS,
      and has no counterpart in previous systems.  The caller
      supplies a QNAME, QTYPE, and QCLASS, and wants all of the
      matching RRs.  This function will often use the DNS format
      for all RR data instead of the local host's, and returns all
      RR content (e.g., TTL) instead of a processed form with local
      quoting conventions.
      </span>
      この機能は DNS から任意の情報を取得するためのもので、過去のシステムにこれに対応する機能はない。呼び出し側は QNAME・QTYPE・QCCLASS を与え、一致するすべての RR を要求する。この機能はしばしば、ローカルホストのフォーマットではなく、すべての RR の DNS フォーマットを使用し、ローカルの引用規則で処理するのではなく、すべての RR の内容(例えば TTL)を返す。
    </p>
  </li>
</ul>
<p>
<span class="original">
When the resolver performs the indicated function, it usually has one of
the following results to pass back to the client:
</span>
  通常、リゾルバが指示された機能を実行したとき、クライアントに以下の結果のひとつが返される：
</p>
<ul>
  <li>
    <span class="original">
   - One or more RRs giving the requested data.
    </span>
    要求された情報を与えるひとつまたは複数の RR
    <p class="nomargin">
      <span class="original">
     In this case the resolver returns the answer in the
     appropriate format.
      </span>
      この場合、リゾルバは適切なフォーマットで回答を返す。
    </p>
  </li>
  <li>
    <a name="INDEX-NE"></a>
    <span class="original">
   - A name error (NE).
    </span>
    名前エラー(NE)
    <p class="nomargin">
      <span class="original">
     This happens when the referenced name does not exist.  For
     example, a user may have mistyped a host name.
      </span>
      参照された名前が存在しない場合に発生する。例えばユーザーがホスト名を間違えて入力した可能性がある。
    </p>
  </li>
  <li>
    <span class="original">
   - A data not found error.
    </span>
    情報なしエラー
    <p class="nomargin">
      <span class="original">
     This happens when the referenced name exists, but data of the
     appropriate type does not.  For example, a host address
     function applied to a mailbox name would return this error
     since the name exists, but no address RR is present.
      </span>
      参照された名前は存在するが、適切なタイプの情報が存在しない場合に発生する。例えばホストアドレス機能にメールボックス名を問い合わせた場合、その名前は存在するが、アドレス RR が存在しないため、このエラーが返されるだろう。
    </p>
  </li>
</ul>
<p>
<span class="original">
It is important to note that the functions for translating between host
names and addresses may combine the "name error" and "data not found"
error conditions into a single type of error return, but the general
function should not.  One reason for this is that applications may ask
first for one type of information about a name followed by a second
request to the same name for some other type of information; if the two
errors are combined, then useless queries may slow the application.
</span>
  ホスト名とアドレスとの変換機能は、"名前エラー(name error)" と "情報なしエラー(data not found)" とを単独の種類のエラーにまとめて返してもよいが、汎用検索機能ではそうでないことに注意してほしい。その理由のひとつは、アプリケーションは名前に付いて最初にひとつの情報タイプを問合せ、続いて他の情報タイプを問い合わせる可能性があるためである。二つのエラーが併せて返された場合、無駄な問合せがアプリケーションの速度を低下させる可能性がある。
</p>

<h4>
<a name="INDEX-ALIASES2"></a>
<span class="original">
5.2.2. Aliases
</span>
5.2.2. エイリアス
</h4>

<p>
<a name="INDEX-CNAME3"></a>
<span class="original">
While attempting to resolve a particular request, the resolver may find
that the name in question is an alias.  For example, the resolver might
find that the name given for host name to address translation is an
alias when it finds the CNAME RR.  If possible, the alias condition
should be signalled back from the resolver to the client.
</span>
  リゾルバは、リクエストを解決しようとしている間に、問題の名前がエイリアスであることを知る可能性がある。例えばリゾルバが CNAME RR を見つけたとき、ホスト名からアドレスへの変換に与えられた名前がエイリアスであることを知るかもしれない。可能なら、エイリアスであるということがリゾルバからクライアントに返されるべきである。
</p>
<p>
<span class="original">
In most cases a resolver simply restarts the query at the new name when
it encounters a CNAME.  However, when performing the general function,
the resolver should not pursue aliases when the CNAME RR matches the
query type.  This allows queries which ask whether an alias is present.
For example, if the query type is CNAME, the user is interested in the
CNAME RR itself, and not the RRs at the name it points to.
</span>
  リゾルバが CNAME に遭遇したとき、たいていは単純にその新しい名前で問合せを再開する。しかしながら汎用検索機能を実行している場合、CNAME RR が問合せタイプに一致するのであれば、リゾルバはエイリアスを追跡しないべきである。これにより、エイリアスが存在しているかどうかを尋ねる問合せが可能となる。例えば問合せタイプが CNAME の場合、ユーザーはその名前が指す RR ではなく、CNAME RR そのものに関心がある。
</p>
<p>
<span class="original">
Several special conditions can occur with aliases.  Multiple levels of
aliases should be avoided due to their lack of efficiency, but should
not be signalled as an error.  Alias loops and aliases which point to
non-existent names should be caught and an error condition passed back
to the client.
</span>
  エイリアスにはいくつかの特殊な状況が発生し得る。多段階のエイリアスは非効率なため避けるべきだが、エラーとして報告されるべきではない。エイリアスのループや存在しない名前を指すエイリアスは検出され、クライアントにエラー状態として返されるべきである。
</p>

<h4>
<span class="original">
5.2.3. Temporary failures
</span>
5.2.3. 一時的障害
</h4>

<p>
<span class="original">
In a less than perfect world, all resolvers will occasionally be unable
to resolve a particular request.  This condition can be caused by a
resolver which becomes separated from the rest of the network due to a
link failure or gateway problem, or less often by coincident failure or
unavailability of all servers for a particular domain.
</span>
  世の中は完全ではないので、リゾルバが特定のリクエストを解決できない場合もある。そのような状況は、回線障害やゲートウェイの不具合のためにリゾルバが他のネットワークから孤立した場合や、可能性は低いものの、ある特定のドメインのためのすべてのサーバーが同時に故障または利用不能になった場合に起こり得る。
</p>
<p>
<span class="original">
It is essential that this sort of condition should not be signalled as a
name or data not present error to applications.  This sort of behavior
is annoying to humans, and can wreak havoc when mail systems use the
DNS.
</span>
  この状態は、名前または情報が存在しないというエラーとしてアプリケーションに通知されるべきではない。そのような動作は人間を悩ませるうえ、メールシステムが DNS を使用している場合には大きな混乱をもたらす可能性がある。
</p>
<p>
<span class="original">
While in some cases it is possible to deal with such a temporary problem
by blocking the request indefinitely, this is usually not a good choice,
particularly when the client is a server process that could move on to
other tasks.  The recommended solution is to always have temporary
failure as one of the possible results of a resolver function, even
though this may make emulation of existing HOSTS.TXT functions more
difficult.
</span>
  リクエストを永久に遮断することでこの種の一時的な問題に対処することも場合によっては可能だが、あまりよい選択ではない。クライアントが他のタスクに繋がるサーバープロセスの場合は特にそうである。推奨される解決法は一時的障害をリゾルバ関数の結果のひとつとして持つことだが、これは既存の HOSTS.TXT の機能の模倣をより困難にする可能性がある。
</p>

<h3>
<span class="original">
5.3. Resolver internals
</span>
5.3. リゾルバ内部
</h3>

<p>
<span class="original">
Every resolver implementation uses slightly different algorithms, and
typically spends much more logic dealing with errors of various sorts
than typical occurances.  This section outlines a recommended basic
strategy for resolver operation, but leaves details to [RFC-1035].
</span>
  すべてのリゾルバ実装は若干異なるアルゴリズムを使用し、一般に、典型的な状況よりも様々なエラーを扱うためにより多くのロジックを費やす。このセクションではリゾルバの運用に推奨される基本的な戦略の概要を説明するが、詳細は [RFC-1035] を参照してほしい。
</p>

<h4>
<a name="INDEX-STUBRESOLVERS"></a>
<span class="original">
5.3.1. Stub resolvers
</span>
5.3.1. スタブリゾルバ
</h4>

<p>
<span class="original">
One option for implementing a resolver is to move the resolution
function out of the local machine and into a name server which supports
recursive queries.  This can provide an easy method of providing domain
service in a PC which lacks the resources to perform the resolver
function, or can centralize the cache for a whole local network or
organization.
</span>
  リゾルバを実装する場合のひとつの選択肢は、解決機能をローカルマシンの外に出し、再帰問合せをサポートするネームサーバーの中に移すことである。これは、リゾルバ機能を実行するリソースを持たない PC にドメインサービスを提供する簡単な方法であり、また、ローカルネットワークまたは組織全体のキャッシュを中央に集中させることができる。
</p>
<p>
<span class="original">
All that the remaining stub needs is a list of name server addresses
that will perform the recursive requests.  This type of resolver
presumably needs the information in a configuration file, since it
probably lacks the sophistication to locate it in the domain database.
The user also needs to verify that the listed servers will perform the
recursive service; a name server is free to refuse to perform recursive
services for any or all clients.  The user should consult the local
system administrator to find name servers willing to perform the
service.
</span>
  他にスタブが必要とするものは、再帰リクエストを実行するネームサーバーの一覧だけである。おそらくこの種のリゾルバはドメインデータベース内でそれを探すための高度な機能を持たないため、構成ファイル内にその情報を必要とするだろう。ネームサーバーは任意の、またはすべてのクライアントに対して再帰サービスの実行を拒否することができるため、ユーザーはリストされたサーバーが再帰サービスを実行できるかどうかを確認する必要がある。ユーザーはサービスを実行する意思のあるネームサーバーを見つけるために、システム管理者に相談するべきである。
</p>
<p>
<span class="original">
This type of service suffers from some drawbacks.  Since the recursive
requests may take an arbitrary amount of time to perform, the stub may
have difficulty optimizing retransmission intervals to deal with both
lost UDP packets and dead servers; the name server can be easily
overloaded by too zealous a stub if it interprets retransmissions as new
requests.  Use of TCP may be an answer, but TCP may well place burdens
on the host's capabilities which are similar to those of a real
resolver.
</span>
  この種のサービスはいくつかの欠点に苦しむことになる。再帰リクエストの実行時間は不定であるため、UPD パケットの喪失とサーバー障害とを扱うための再送信間隔の最適化には困難が伴なう。熱心なスタブによる新しいリクエストに割り込まれることで、ネームサーバーは簡単に過負荷状態になる。TCP の使用がその解決策となるかもしれないが、TCP は本物のリゾルバと同等の負荷をそのホストにかけることになるだろう。
</p>

<h4>
<span class="original">
5.3.2. Resources
</span>
5.3.2. リソース
</h4>

<p>
<span class="original">
In addition to its own resources, the resolver may also have shared
access to zones maintained by a local name server.  This gives the
resolver the advantage of more rapid access, but the resolver must be
careful to never let cached information override zone data.  In this
discussion the term "local information" is meant to mean the union of
the cache and such shared zones, with the understanding that
authoritative data is always used in preference to cached data when both
are present.
</span>
  リゾルバは自身のリソースに加え、ローカルのネームサーバーによって維持されるゾーンへのアクセスを共有してよい。これはより迅速なアクセスという利点をリゾルバに与えるが、リゾルバはキャッシュ情報がゾーン情報に優先しないよう注意しなければならない。この議論における "ローカル情報(local information)" という用語は、キャッシュ情報と権威情報とが共に存在する場合には権威情報が優先されるという了解のもと、キャッシュと共有されたゾーンとの集合を意味することを意図している。
</p>
<p>
<span class="original">
The following resolver algorithm assumes that all functions have been
converted to a general lookup function, and uses the following data
structures to represent the state of a request in progress in the
resolver:
</span>
  以下のリゾルバアルゴリズムは、すべての機能が汎用検索機能に変換されたものと仮定しており、リゾルバ内で進行中のリクエストの状態を表すために以下のデータ構造を使用する：
</p>
<dl>
  <dt>
    SNAME
  </dt>
  <dd>
    <span class="original">
                the domain name we are searching for.
    </span>
    探しているドメイン名
  </dd>
  <dt>
    STYPE
  </dt>
  <dd>
    <span class="original">
                the QTYPE of the search request.
    </span>
    検索リクエストの QTYPE。
  </dd>
  <dt>
    SCLASS
  </dt>
  <dd>
    <span class="original">
                the QCLASS of the search request.
    </span>
    検索リクエストの QCLASS。
  </dd>
  <dt>
    SLIST
  </dt>
  <dd>
    <span class="original">
                a structure which describes the name servers and the
                zone which the resolver is currently trying to query.
                This structure keeps track of the resolver's current
                best guess about which name servers hold the desired
                information; it is updated when arriving information
                changes the guess.  This structure includes the
                equivalent of a zone name, the known name servers for
                the zone, the known addresses for the name servers, and
                history information which can be used to suggest which
                server is likely to be the best one to try next.  The
                zone name equivalent is a match count of the number of
                labels from the root down which SNAME has in common with
                the zone being queried; this is used as a measure of how
                "close" the resolver is to SNAME.
    </span>
    リゾルバが現在問合せを試みているネームサーバーとゾーンとを記述する構造体。この構造体は、どのネームサーバーが目的の情報を保持しているかに関して、リゾルバの現在の最善の予測を記録し、その予測を変更する情報が届くと更新される。この構造体は、ゾーン名一致数、そのゾーンのための既知のネームサーバー、そのネームサーバーのための既知のアドレス、そして、次に試みるのに最適と思われるサーバーを示すために使用できる履歴情報を含む。ゾーン名一致数は、問合せられたゾーンと SNAME とで共有するルートからのラベルの一致数である。これは、リゾルバが SNAME にどれだけ "近い(close)" かの尺度として使用される。
  </dd>
  <dt>
    <a name="INDEX-SAFETYBELT"></a>
    SBELT
  </dt>
  <dd>
    <span class="original">
                a "safety belt" structure of the same form as SLIST,
                which is initialized from a configuration file, and
                lists servers which should be used when the resolver
                doesn't have any local information to guide name server
                selection.  The match count will be -1 to indicate that
                no labels are known to match.
    </span>
    SLIST と同じ形式の "安全ベルト(safety belt)" 構造体で、構成ファイルにより初期化される。これは、リゾルバがネームサーバーの選択を導くためのローカル情報を何も持たないときに使用するサーバーのリストである。SBELT の一致数は、一致したことの分かっているラベルがないことを表す -1 になるだろう。
  </dd>
  <dt>
    CACHE
  </dt>
  <dd>
    <span class="original">
                A structure which stores the results from previous
                responses.  Since resolvers are responsible for
                discarding old RRs whose TTL has expired, most
                implementations convert the interval specified in
                arriving RRs to some sort of absolute time when the RR
                is stored in the cache.  Instead of counting the TTLs
                down individually, the resolver just ignores or discards
                old RRs when it runs across them in the course of a
                search, or discards them during periodic sweeps to
                reclaim the memory consumed by old RRs.
    </span>
    直前の応答の結果を保持する構造体。リゾルバは TTL の切れた古い RR を破棄する責任を持つため、RR がキャッシュに保持されたとき、大部分の実装はその RR に指定されている間隔を何らかの絶対時刻に変換する。リゾルバは TTL を個別にカウントダウンする代わりに、検索の過程で古い RR を無視または破棄するか、古い RR により消費されたメモリを再要求するための定期的なメモリ解放の間に破棄すればよい。
  </dd>
</dl>

<h4>
<span class="original">
5.3.3. Algorithm
</span>
5.3.3. アルゴリズム
</h4>

<p>
<span class="original">
The top level algorithm has four steps:
</span>
  最上位レベルのアルゴリズムは 4 つのステップを持つ：
</p>
<ul>
  <li>
    <span class="original">
   1. See if the answer is in local information, and if so return
      it to the client.
    </span>
    1. 答えがローカル情報にあるかるかどうかを確認し、もしあればそれをクライアントに返す。
  </li>
  <li>
    <span class="original">
   2. Find the best servers to ask.
    </span>
    2. 尋ねるのに最適なサーバーを探す。
  </li>
  <li>
    <span class="original">
   3. Send them queries until one returns a response.
    </span>
    3. 応答が返されるまで問合せを送信する。
  </li>
  <li>
    <span class="original">
   4. Analyze the response, either:
    </span>
    4. 応答を解析する：
    <ul class="nomargin">
    <br>
      <li>
        <span class="original">
         a. if the response answers the question or contains a name
            error, cache the data as well as returning it back to
            the client.
        </span>
        a. その応答が問合せの回答そのものかネームエラーを含む場合、その情報をクライアントに返すとともに、それをキャッシュする。
      </li>
      <li>
        <span class="original">
         b. if the response contains a better delegation to other
            servers, cache the delegation information, and go to
            step 2.
        </span>
        b. より適した他サーバーへの委譲が応答に含まれている場合、その委譲情報をキャッシュし、ステップ 2 に進む。
      </li>
      <li>
        <span class="original">
         c. if the response shows a CNAME and that is not the
            answer itself, cache the CNAME, change the SNAME to the
            canonical name in the CNAME RR and go to step 1.
        </span>
        c. 応答が CNAME を表しており、かつそれが回答そのものではない場合、その CNAME をキャッシュし、SNAME を CNAME RR 内の正規名に変更し、ステップ 1 に進む。
      </li>
      <li>
        <span class="original">
         d. if the response shows a servers failure or other
            bizarre contents, delete the server from the SLIST and
            go back to step 3.
        </span>
        d. 応答がサーバー障害などの異常を表している場合、SLIST からそのサーバーを削除し、ステップ 3 に戻る。
      </li>
    </ul>
  </li>
</ul>
<p>
<span class="original">
Step 1 searches the cache for the desired data. If the data is in the
cache, it is assumed to be good enough for normal use.  Some resolvers
have an option at the user interface which will force the resolver to
ignore the cached data and consult with an authoritative server.  This
is not recommended as the default.  If the resolver has direct access to
a name server's zones, it should check to see if the desired data is
present in authoritative form, and if so, use the authoritative data in
preference to cached data.
</span>
  ステップ 1 では目的の情報をキャッシュから検索する。キャッシュ内に情報が見つかった場合、それは通常の使用に十分であると見なされる。一部のリゾルバは、ユーザーがリゾルバにキャッシュ情報を無視させ、権威サーバーに尋ねることを強制するユーザーインターフェイスのオプションを持つ。これはデフォルトとしては推奨されない。リゾルバがネームサーバーのゾーンに直接アクセスできる場合、目的の情報が権威を持つ形で提供されているかどうかを確認し、もしそうであれば、キャッシュ情報に優先してその権威情報を使用するべきである。
</p>
<p>
<span class="original">
Step 2 looks for a name server to ask for the required data.  The
general strategy is to look for locally-available name server RRs,
starting at SNAME, then the parent domain name of SNAME, the
grandparent, and so on toward the root.  Thus if SNAME were
Mockapetris.ISI.EDU, this step would look for NS RRs for
Mockapetris.ISI.EDU, then ISI.EDU, then EDU, and then . (the root).
These NS RRs list the names of hosts for a zone at or above SNAME.  Copy
the names into SLIST.  Set up their addresses using local data.  It may
be the case that the addresses are not available.  The resolver has many
choices here; the best is to start parallel resolver processes looking
for the addresses while continuing onward with the addresses which are
available.  Obviously, the design choices and options are complicated
and a function of the local host's capabilities.  The recommended
priorities for the resolver designer are:
</span>
  ステップ 2 では要求された情報を尋ねるべきネームーサーバーを探す。一般的な戦略は、ローカルで利用可能なネームサーバー RR を、SNAME から始め、SNAME の親ドメイン、そのまた親のドメインと続け、ルートまで探すことである。したがって SNAME が Mockapetris.ISI.EDU であった場合、このステップはまず Mockapetris.ISI.EDU のための NS RR を探し、次に ISI.EDU、次に EDU、そして . (ルート)と探すことになる。これらの NS RR は、SNAME のゾーンかその上位ゾーンかのためのホスト名をリストする。それらの名前を SLIST にコピーする。ローカル情報を使用してそれらのアドレスを設定する。アドレスを利用できない可能性もある。その場合リゾルバには多くの選択肢がある。もっとも優れている選択は、利用可能なアドレスを使用して処理を進めながら、アドレスを探すリゾルバプロセスを並行して開始することである。明らかにこの設計の選択とオプションとは複雑であり、ローカルホストの役割である。リゾルバ設計者に推奨される優先順位は以下の通り：
</p>
<ul>
  <li>
    <span class="original">
   1. Bound the amount of work (packets sent, parallel processes
      started) so that a request can't get into an infinite loop or
      start off a chain reaction of requests or queries with other
      implementations EVEN IF SOMEONE HAS INCORRECTLY CONFIGURED
      SOME DATA.
    </span>
    1. 間違って情報を設定した場合でも、リクエストが無限ループに陥ったり、他の実装とのリクエストまたは問合せの連鎖反応を起こしたりしないように、作業(送信パケット数、並列プロセス数)の量を抑制する。
  </li>
  <li>
    <span class="original">
   2. Get back an answer if at all possible.
    </span>
    2. とにかく回答を返す。
  </li>
  <li>
    <span class="original">
   3. Avoid unnecessary transmissions.
    </span>
    3. 不要な通信を避ける。
  </li>
  <li>
    <span class="original">
   4. Get the answer as quickly as possible.
    </span>
    4. 出来るだけ早く回答を返す。
  </li>
</ul>
<p>
<span class="original">
If the search for NS RRs fails, then the resolver initializes SLIST from
the safety belt SBELT.  The basic idea is that when the resolver has no
idea what servers to ask, it should use information from a configuration
file that lists several servers which are expected to be helpful.
Although there are special situations, the usual choice is two of the
root servers and two of the servers for the host's domain.  The reason
for two of each is for redundancy.  The root servers will provide
eventual access to all of the domain space.  The two local servers will
allow the resolver to continue to resolve local names if the local
network becomes isolated from the internet due to gateway or link
failure.
</span>
  NS RR の検索に失敗すると、リゾルバは SLIST を安全ベルト SBELT で初期化する。基本的な思想は、リゾルバがどのサーバーに尋ねるべきかを知らない場合、手掛かりとなるであろうサーバー群をリストした設定ファイルの情報を使用するべきというものである。特殊な状況はあるものの、通常の選択は、二つのルートサーバーとそのホストのドメインのための 二つのサーバーとである。二つであるのは冗長性のためである。ルートサーバーは、結果として全ドメイン空間へのアクセスを提供する。ローカルサーバーが二つあることにより、ゲートウェイや回線障害によってローカルネットワークがインターネットから分離された場合でも、ローカルの名前解決を継続できるだろう。
</p>
<p>
<span class="original">
In addition to the names and addresses of the servers, the SLIST data
structure can be sorted to use the best servers first, and to insure
that all addresses of all servers are used in a round-robin manner.  The
sorting can be a simple function of preferring addresses on the local
network over others, or may involve statistics from past events, such as
previous response times and batting averages.
</span>
  サーバーの名前とアドレスとに加え、最適なサーバーから先に使用するために、またすべてのサーバーのすべてのアドレスがラウンドロビン方式で使用されることを保証するために、SLIST 構造体をソートすることができる。このソートは、ローカルネットワーク上のアドレスを他に優先するような単純なものでもよいし、以前の応答時間や成功率など、過去のイベントからの統計を考慮してもよい。
</p>
<p>
<span class="original">
Step 3 sends out queries until a response is received.  The strategy is
to cycle around all of the addresses for all of the servers with a
timeout between each transmission.  In practice it is important to use
all addresses of a multihomed host, and too aggressive a retransmission
policy actually slows response when used by multiple resolvers
contending for the same name server and even occasionally for a single
resolver.  SLIST typically contains data values to control the timeouts
and keep track of previous transmissions.
</span>
  ステップ 3 では応答を受け取るまで問合せを送信する。その戦略は、各送信ごとにタイムアウトさせながら、すべてのサーバーのすべてのアドレスを巡回するというものである。実際問題として、マルチホーム化されたホストのすべてのアドレスを使用することは重要であり、また積極的すぎる再送信ポリシーは、複数のリゾルバ(時には単一のリゾルバでも)が同じネームサーバーに対して競合した場合の応答を遅らせる。一般に SLIST はタイムアウトを制御し、以前の送信を追跡するためのデータ値を含む。
</p>
<p>
<span class="original">
Step 4 involves analyzing responses.  The resolver should be highly
paranoid in its parsing of responses.  It should also check that the
response matches the query it sent using the ID field in the response.
</span>
  ステップ 4 は応答の解析を必要とする。リゾルバは応答の解析において非常に柔軟であるべきである。またリゾルバは、送信した問合せに対応する応答かどうかを、応答の ID フィールドを使用して確認する。
</p>
<p>
<a name="INDEX-NAMEERROR2"></a>
<span class="original">
The ideal answer is one from a server authoritative for the query which
either gives the required data or a name error.  The data is passed back
to the user and entered in the cache for future use if its TTL is
greater than zero.
</span>
  理想的な回答は、問い合わせに対して権威あるサーバーからの、目的の情報または名前エラーを表すものである。情報はユーザーに渡され、TTL がゼロより大きければ将来のためにキャッシュに入れられる。
</p>
<p>
<span class="original">
If the response shows a delegation, the resolver should check to see
that the delegation is "closer" to the answer than the servers in SLIST
are.  This can be done by comparing the match count in SLIST with that
computed from SNAME and the NS RRs in the delegation.  If not, the reply
is bogus and should be ignored.  If the delegation is valid the NS
delegation RRs and any address RRs for the servers should be cached.
The name servers are entered in the SLIST, and the search is restarted.
</span>
  応答が委譲を示している場合、リゾルバは、その委譲が SLIST 内のサーバーより回答に "近い(closer)" かどうかを確認するべきである。これは SLIST 内の一致数を、委譲内の SNAME と NS RR とから計算されたものと比較することで実現できる。もし近くないのであればその応答は間違いであり、無視するべきである。委譲が有効な場合、そのサーバーのための NS 委譲 RR と任意のアドレス RR とはキャッシュされるべきである。ネームサーバーは SLIST に入れられ、検索が再開される。
</p>
<p>
<span class="original">
If the response contains a CNAME, the search is restarted at the CNAME
unless the response has the data for the canonical name or if the CNAME
is the answer itself.
</span>
  応答が CNAME を含む場合、その CNAME から検索が再開される。ただしその応答が正規名の情報を持っているか、CNAME が回答そのものである場合を除く。
</p>
<p>
<span class="original">
Details and implementation hints can be found in [RFC-1035].
</span>
  詳細と実装との手引きは [RFC-1035] に見つけれらる。
</p>

<h2>
<span class="original">
6. A SCENARIO
</span>
6. シナリオ
</h2>

<p>
<span class="original">
In our sample domain space, suppose we wanted separate administrative
control for the root, MIL, EDU, MIT.EDU and ISI.EDU zones.  We might
allocate name servers as follows:
</span>
  私たちのサンプルドメイン空間では、ルート、MIL、EDU、MIT.EDU、ISI.EDU の各ゾーンに個別の運用管理を求めていると仮定する。私たちは以下のようにネームサーバーを割り当てるだろう：
</p>
<pre>                                   |(C.ISI.EDU,SRI-NIC.ARPA
                                   | A.ISI.EDU)
             +---------------------+------------------+
             |                     |                  |
            MIL                   EDU                ARPA
             |(SRI-NIC.ARPA,       |(SRI-NIC.ARPA,    |
             | A.ISI.EDU           | C.ISI.EDU)       |
       +-----+-----+               |     +------+-----+-----+
       |     |     |               |     |      |           |
      BRL  NOSC  DARPA             |  IN-ADDR  SRI-NIC     ACC
                                   |
       +--------+------------------+---------------+--------+
       |        |                  |               |        |
      UCI      MIT                 |              UDEL     YALE
                |(XX.LCS.MIT.EDU, ISI
                |ACHILLES.MIT.EDU) |(VAXA.ISI.EDU,VENERA.ISI.EDU,
            +---+---+              | A.ISI.EDU)
            |       |              |
           LCS   ACHILLES +--+-----+-----+--------+
            |             |  |     |     |        |
            XX            A  C   VAXA  VENERA Mockapetris
</pre>
<p>
<span class="original">
In this example, the authoritative name server is shown in parentheses
at the point in the domain tree at which is assumes control.
</span>
  この例において、権威ネームサーバーは制御を担うドメインツリーの位置に括弧で示されている。
</p>
<p>
<span class="original">
Thus the root name servers are on C.ISI.EDU, SRI-NIC.ARPA, and
A.ISI.EDU.  The MIL domain is served by SRI-NIC.ARPA and A.ISI.EDU.  The
EDU domain is served by SRI-NIC.ARPA. and C.ISI.EDU.  Note that servers
may have zones which are contiguous or disjoint.  In this scenario,
C.ISI.EDU has contiguous zones at the root and EDU domains.  A.ISI.EDU
has contiguous zones at the root and MIL domains, but also has a non-
contiguous zone at ISI.EDU.
</span>
  したがってルートネームサーバーは C.ISI.EDU、SRI-NIC.ARPA、A.ISI.EDU 上にある。MIL ドメインは SRI-NIC.ARPA と A.ISI.EDU とによって提供される。EDU ドメインは SRI-NIC.ARPA と C.ISI.EDU とによって提供される。サーバーが保持するドメインのゾーンは隣接していても離れていてもよいことに注意してほしい。このシナリオでは、C.ISI.EDU はルートと EDU ドメインとに隣接するゾーンを持つ。A.ISI.EDU はルートと MIL ドメインとに隣接するゾーンを持つが、同時に ISI.EDU に隣接しないゾーンを持つ。
</p>

<h3>
<span class="original">
6.1. C.ISI.EDU name server
</span>
6.1. C.ISI.EDU ネームサーバー
</h3>

<p>
<span class="original">
C.ISI.EDU is a name server for the root, MIL, and EDU domains of the IN
class, and would have zones for these domains.  The zone data for the
root domain might be:
</span>
  C.ISI.EDU は IN クラスのルート・MIL・EDU ドメインのネームサーバーであり、それらのドメインのゾーンを保持しているだろう。ルートのゾーン情報は次のようになるだろう：
</p>
<pre>    .       IN      SOA     SRI-NIC.ARPA. HOSTMASTER.SRI-NIC.ARPA. (
                            870611          ;serial
                            1800            ;refresh every 30 min
                            300             ;retry every 5 min
                            604800          ;expire after a week
                            86400)          ;minimum of a day
                    NS      A.ISI.EDU.
                    NS      C.ISI.EDU.
                    NS      SRI-NIC.ARPA.

    MIL.    86400   NS      SRI-NIC.ARPA.
            86400   NS      A.ISI.EDU.

    EDU.    86400   NS      SRI-NIC.ARPA.
            86400   NS      C.ISI.EDU.

    SRI-NIC.ARPA.   A       26.0.0.73
                    A       10.0.0.51
                    MX      0 SRI-NIC.ARPA.
                    HINFO   DEC-2060 TOPS20

    ACC.ARPA.       A       26.6.0.65
                    HINFO   PDP-11/70 UNIX
                    MX      10 ACC.ARPA.

    USC-ISIC.ARPA.  CNAME   C.ISI.EDU.

    73.0.0.26.IN-ADDR.ARPA.  PTR    SRI-NIC.ARPA.
    65.0.6.26.IN-ADDR.ARPA.  PTR    ACC.ARPA.
    51.0.0.10.IN-ADDR.ARPA.  PTR    SRI-NIC.ARPA.
    52.0.0.10.IN-ADDR.ARPA.  PTR    C.ISI.EDU.
    103.0.3.26.IN-ADDR.ARPA. PTR    A.ISI.EDU.

    A.ISI.EDU. 86400 A      26.3.0.103
    C.ISI.EDU. 86400 A      10.0.0.52
</pre>
<p>
<span class="original">
This data is represented as it would be in a master file.  Most RRs are
single line entries; the sole exception here is the SOA RR, which uses
"(" to start a multi-line RR and ")" to show the end of a multi-line RR.
Since the class of all RRs in a zone must be the same, only the first RR
in a zone need specify the class.  When a name server loads a zone, it
forces the TTL of all authoritative RRs to be at least the MINIMUM field
of the SOA, here 86400 seconds, or one day.  The NS RRs marking
delegation of the MIL and EDU domains, together with the glue RRs for
the servers host addresses, are not part of the authoritative data in
the zone, and hence have explicit TTLs.
</span>
  この情報はマスターファイルにあるであろう通りに示されている。大部分の RR は単一行のエントリである。唯一の例外は SOA RR で、複数行 RR の開始のために "(" を使用し、また複数行 RR の終了を表すために ")" を使用している。あるゾーン内のすべての RR は同じクラスでなければならないので、ゾーン内の最初の RR にだけクラスを指定する必要がある。ネームサーバーがゾーンを読み込むとき、すべての権威 RR の TTL を少なくとも SOA の MINIMUM フィールドの値、ここでは 86400 秒(1 日)に強制する。MIL ドメインおよび EDU ドメインの委譲をサーバーのホストアドレスのグルー RR と共に表している NS RR は、このゾーンの権威情報ではないため、明示的な TTL を持っている。
</p>
<p>
<span class="original">
Four RRs are attached to the root node: the SOA which describes the root
zone and the 3 NS RRs which list the name servers for the root.  The
data in the SOA RR describes the management of the zone.  The zone data
is maintained on host SRI-NIC.ARPA, and the responsible party for the
zone is HOSTMASTER@SRI-NIC.ARPA.  A key item in the SOA is the 86400
second minimum TTL, which means that all authoritative data in the zone
has at least that TTL, although higher values may be explicitly
specified.
</span>
  4 つの RR がルートノードに接続している。ルートゾーンを記述する SOA と、そのルートのためのネームサーバーをリストしている 3 つの NS RR である。SOA RR 内の情報はこのゾーンの取り扱いを記述する。ゾーン情報はホスト SRI-NIC.ARPA 上で保守され、ゾーンに責任を持つ関係者は HOSTMASTER@SRI-NIC.ARPA である。SOA 内の重要な項目は 86400 秒の最低 TTL であり、明示的にそれ以上の値を指定することはできるものの、ゾーン内のすべての権威情報が少なくともその TTL を持つことを意味している。
</p>
<p>
<span class="original">
The NS RRs for the MIL and EDU domains mark the boundary between the
root zone and the MIL and EDU zones.  Note that in this example, the
lower zones happen to be supported by name servers which also support
the root zone.
</span>
  MIL ドメインおよび EDU ドメインのための NS RR は、ルートゾーンと MIL・EDU ゾーンとの間の境界を表している。この例では、ルートゾーンをサポートするネームサーバーが、たまたま下位ゾーンもサポートしていることに注意してほしい。
</p>
<p>
<span class="original">
The master file for the EDU zone might be stated relative to the origin
EDU.  The zone data for the EDU domain might be:
</span>
  EDU ゾーンのためのマスターファイルは、基点である EDU に対する相対位置から開始することができる。EDU ドメインのゾーン情報は以下のようになるだろう：
</p>
<pre>    EDU.  IN SOA SRI-NIC.ARPA. HOSTMASTER.SRI-NIC.ARPA. (
                            870729 ;serial
                            1800 ;refresh every 30 minutes
                            300 ;retry every 5 minutes
                            604800 ;expire after a week
                            86400 ;minimum of a day
                            )
                    NS SRI-NIC.ARPA.
                    NS C.ISI.EDU.

    UCI 172800 NS ICS.UCI
                    172800 NS ROME.UCI
    ICS.UCI 172800 A 192.5.19.1
    ROME.UCI 172800 A 192.5.19.31
    ISI 172800 NS VAXA.ISI
                    172800 NS A.ISI
                    172800 NS VENERA.ISI.EDU.
    VAXA.ISI 172800 A 10.2.0.27
                    172800 A 128.9.0.33
    VENERA.ISI.EDU. 172800 A 10.1.0.52
                    172800 A 128.9.0.32
    A.ISI 172800 A 26.3.0.103

    UDEL.EDU.  172800 NS LOUIE.UDEL.EDU.
                    172800 NS UMN-REI-UC.ARPA.
    LOUIE.UDEL.EDU. 172800 A 10.0.0.96
                    172800 A 192.5.39.3

    YALE.EDU.  172800 NS YALE.ARPA.
    YALE.EDU.  172800 NS YALE-BULLDOG.ARPA.

    MIT.EDU.  43200 NS XX.LCS.MIT.EDU.
                      43200 NS ACHILLES.MIT.EDU.
    XX.LCS.MIT.EDU.  43200 A 10.0.0.44
    ACHILLES.MIT.EDU. 43200 A 18.72.0.8
</pre>
<p>
<span class="original">
Note the use of relative names here.  The owner name for the ISI.EDU. is
stated using a relative name, as are two of the name server RR contents.
Relative and absolute domain names may be freely intermixed in a master
</span>
  ここでは相対名の使用法に注意してほしい。ISI.EDU. の所有者名の二つのネームサーバー RR が相対名を使用して記述されている。マスターファイル内では相対ドメイン名と絶対ドメイン名とを自由に混在させてよい。
</p>

<h3>
<span class="original">
6.2. Example standard queries
</span>
6.2. 標準問合せの例
</h3>

<p>
<span class="original">
The following queries and responses illustrate name server behavior.
Unless otherwise noted, the queries do not have recursion desired (RD)
in the header.  Note that the answers to non-recursive queries do depend
on the server being asked, but do not depend on the identity of the
requester.
</span>
  以下の問合せと応答は、ネームサーバーの振る舞いの説明である。特に記述のない限り、問合せは再帰要求(RD)を持たない。非再帰問合せへの回答は尋ねているサーバーに依存し、リクエスタには依存しないことに注意してほしい。
</p>

<h4>
6.2.1. QNAME=SRI-NIC.ARPA, QTYPE=A
</h4>

<p>
<span class="original">
The query would look like:
</span>
  問合せは以下のようになるだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY                                     |
               +---------------------------------------------------+
    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A           |
               +---------------------------------------------------+
    Answer     | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
The response from C.ISI.EDU would be:
</span>
  C.ISI.EDU からの応答は以下のようになるだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE, AA                       |
               +---------------------------------------------------+
    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A           |
               +---------------------------------------------------+
    Answer     | SRI-NIC.ARPA. 86400 IN A 26.0.0.73                |
               |               86400 IN A 10.0.0.51                |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
The header of the response looks like the header of the query, except
that the RESPONSE bit is set, indicating that this message is a
response, not a query, and the Authoritative Answer (AA) bit is set
indicating that the address RRs in the answer section are from
authoritative data.  The question section of the response matches the
question section of the query.
</span>
  応答のヘッダは問合せのヘッダと同じように見えるが、メッセージが応答であることを表すために RESPONSE ビットがセットされており、また Answer セクション内のアドレス RR が権威情報に由来することを表すために、Authoritative Answer (AA) がセットされている。応答の Question セクションは問合せの Question セクションに一致する。
</p>
<p>
<span class="original">
If the same query was sent to some other server which was not
authoritative for SRI-NIC.ARPA, the response might be:
</span>
  SRI-NIC.ARPA の権威ではない他のサーバーに同じ問合せが送られた場合、その応答は以下のようになるだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY,RESPONSE                            |
               +---------------------------------------------------+
    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A           |
               +---------------------------------------------------+
    Answer     | SRI-NIC.ARPA. 1777 IN A 10.0.0.51                 |
               |               1777 IN A 26.0.0.73                 |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
This response is different from the previous one in two ways: the header
does not have AA set, and the TTLs are different.  The inference is that
the data did not come from a zone, but from a cache.  The difference
between the authoritative TTL and the TTL here is due to aging of the
data in a cache.  The difference in ordering of the RRs in the answer
section is not significant.
</span>
  この応答は二つの点で前のものと異なっている：ヘッダの AA がセットされておらず、TTL が異なる。推測では、この情報はゾーンからではなく、キャッシュから来ている。ここでの TTL と権威 TTL との違いは、キャッシュ内の情報の経過時間によるものである。Answer セクション内の RR の順序の違いは重要ではない。
</p>

<h4>
6.2.2. QNAME=SRI-NIC.ARPA, QTYPE=*
</h4>

<p>
<span class="original">
A query similar to the previous one, but using a QTYPE of *, would
receive the following response from C.ISI.EDU:
</span>
  前の問合せと似ているが QTYPE に * を使用するこの問合せは、C.ISI.EDU から以下の応答を受け取るだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE, AA                       |
               +---------------------------------------------------+
    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=*           |
               +---------------------------------------------------+
    Answer     | SRI-NIC.ARPA. 86400 IN  A     26.0.0.73           |
               |                         A     10.0.0.51           |
               |                         MX    0 SRI-NIC.ARPA.     |
               |                         HINFO DEC-2060 TOPS20     |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
If a similar query was directed to two name servers which are not
authoritative for SRI-NIC.ARPA, the responses might be:
</span>
  SRI-NIC.ARPA に権威を持たない二つのネームサーバーに同様の問合せが送られた場合、その応答は以下のようになるだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE                           |
               +---------------------------------------------------+
    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=*           |
               +---------------------------------------------------+
    Answer     | SRI-NIC.ARPA. 12345 IN     A       26.0.0.73      |
               |                            A       10.0.0.51      |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
and
</span>
  そして、
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE                           |
               +---------------------------------------------------+
    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=*           |
               +---------------------------------------------------+
    Answer     | SRI-NIC.ARPA. 1290 IN HINFO  DEC-2060 TOPS20      |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
Neither of these answers have AA set, so neither response comes from
authoritative data.  The different contents and different TTLs suggest
that the two servers cached data at different times, and that the first
server cached the response to a QTYPE=A query and the second cached the
response to a HINFO query.
</span>
  どちらの回答も AA がセットされておらず、したがって権威情報からの応答ではない。異なる内容と異なる TTL とは、二つのサーバーが異なる時刻に情報をキャッシュしたことを表しており、最初のサーバーは QTYPE=A への応答をキャッシュし、二番目のサーバーは HINFO 問合せへの応答をキャッシュしている。
</p>

<h4>
6.2.3. QNAME=SRI-NIC.ARPA, QTYPE=MX
</h4>

<p>
<span class="original">
This type of query might be result from a mailer trying to look up
routing information for the mail destination HOSTMASTER@SRI-NIC.ARPA.
The response from C.ISI.EDU would be:
</span>
  この種類の問合せは、メールの宛先 HOSTMASTER@SRI-NIC.ARPA のためのルーティング情報を探そうとするメーラーによって生成される可能性がある。C.ISI.EDU からの応答は以下のようになるだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE, AA                       |
               +---------------------------------------------------+
    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=MX          |
               +---------------------------------------------------+
    Answer     | SRI-NIC.ARPA. 86400 IN     MX      0 SRI-NIC.ARPA.|
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | SRI-NIC.ARPA. 86400 IN     A       26.0.0.73      |
               |                            A       10.0.0.51      |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
This response contains the MX RR in the answer section of the response.
The additional section contains the address RRs because the name server
at C.ISI.EDU guesses that the requester will need the addresses in order
to properly use the information carried by the MX.
</span>
  この応答は Answer セクションに MX RR を含んでいる。Additional セクションにアドレス RR が含まれている。これは C.ISI.EDU のネームサーバーが、MX によって運ばれる情報を適切に使用するためにはリクエスタがそのアドレスを必要とするだろうと推測しているためである。
</p>

<h4>
6.2.4. QNAME=SRI-NIC.ARPA, QTYPE=NS
</h4>

<p>
<span class="original">
C.ISI.EDU would reply to this query with:
</span>
  この問合せに対し C.ISI.EDU は以下のように返すだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE, AA                       |
               +---------------------------------------------------+
    Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=NS          |
               +---------------------------------------------------+
    Answer     | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
The only difference between the response and the query is the AA and
RESPONSE bits in the header.  The interpretation of this response is
that the server is authoritative for the name, and the name exists, but
no RRs of type NS are present there.
</span>
  この応答と問合せとの違いは、ヘッダの AA ビットおよび RESPONSE ビットがセットされていることだけである。この応答は、そのサーバーがその名前の権威を持ち、その名前は存在するが、タイプ NS の RR は存在しないと解釈される。
</p>

<h4>
6.2.5. QNAME=SIR-NIC.ARPA, QTYPE=A
</h4>

<p>
<span class="original">
If a user mistyped a host name, we might see this type of query.
</span>
  ユーザーがホスト名をミスタイプした場合に、この種の問合せに遭遇する可能性がある。
</p>
<p>
<span class="original">
C.ISI.EDU would answer it with:
</span>
  これに対し C.ISI.EDU は以下のように答えるだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE, AA, RCODE=NE             |
               +---------------------------------------------------+
    Question   | QNAME=SIR-NIC.ARPA., QCLASS=IN, QTYPE=A           |
               +---------------------------------------------------+
    Answer     | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Authority  | . SOA SRI-NIC.ARPA. HOSTMASTER.SRI-NIC.ARPA.      |
               |       870611 1800 300 604800 86400                |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
This response states that the name does not exist.  This condition is
signalled in the response code (RCODE) section of the header.
</span>
  この応答はその名前が存在しないことを示している。この状態はヘッダの応答コード(RCODE)で伝えられる。
</p>
<p>
<a name="INDEX-NEGATIVECACHING"></a>
<span class="original">
The SOA RR in the authority section is the optional negative caching
information which allows the resolver using this response to assume that
the name will not exist for the SOA MINIMUM (86400) seconds.
</span>
  Authority セクションの SOA RR はオプションの否定キャッシュ情報である。これによりこの応答を使用するリゾルバは、その名前が SOA MINIMUM (86400) 秒間存在しなかったと推測できる。
</p>

<h4>
6.2.6. QNAME=BRL.MIL, QTYPE=A
</h4>

<p>
<span class="original">
If this query is sent to C.ISI.EDU, the reply would be:
</span>
  この問合せが C.ISI.EDU に送られた場合、その応答は以下のようになるだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE                           |
               +---------------------------------------------------+
    Question   | QNAME=BRL.MIL, QCLASS=IN, QTYPE=A                 |
               +---------------------------------------------------+
    Answer     | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Authority  | MIL.             86400 IN NS       SRI-NIC.ARPA.  |
               |                  86400    NS       A.ISI.EDU.     |
               +---------------------------------------------------+
    Additional | A.ISI.EDU.                A        26.3.0.103     |
               | SRI-NIC.ARPA.             A        26.0.0.73      |
               |                           A        10.0.0.51      |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
This response has an empty answer section, but is not authoritative, so
it is a referral.  The name server on C.ISI.EDU, realizing that it is
not authoritative for the MIL domain, has referred the requester to
servers on A.ISI.EDU and SRI-NIC.ARPA, which it knows are authoritative
for the MIL domain.
</span>
  この応答は空の Answer セクションを持つが、権威を持たず、したがって参照である。C.ISI.EDU 上のネームサーバーは自身が MIL ドメインの権威ではないことを知っているため、MIL ドメインの権威であることを知っている A.ISI.EDU および SRI-NIC.ARPA 上のサーバーをリクエスタに参照させたということである。
</p>

<h4>
6.2.7. QNAME=USC-ISIC.ARPA, QTYPE=A
</h4>

<p>
<span class="original">
The response to this query from A.ISI.EDU would be:
</span>
  この問合せに対する A.ISI.EDU からの応答は以下のようになるだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE, AA                       |
               +---------------------------------------------------+
    Question   | QNAME=USC-ISIC.ARPA., QCLASS=IN, QTYPE=A          |
               +---------------------------------------------------+
    Answer     | USC-ISIC.ARPA. 86400 IN CNAME      C.ISI.EDU.     |
               | C.ISI.EDU.     86400 IN A          10.0.0.52      |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
Note that the AA bit in the header guarantees that the data matching
QNAME is authoritative, but does not say anything about whether the data
for C.ISI.EDU is authoritative.  This complete reply is possible because
A.ISI.EDU happens to be authoritative for both the ARPA domain where
USC-ISIC.ARPA is found and the ISI.EDU domain where C.ISI.EDU data is
found.
</span>
  ヘッダの AA ビットは、QNAME に一致する情報が権威を持つが、C.ISI.EDU のための情報が権威を持つかどうかに付いては何も述べていないことに注意してほしい。A.ISI.EDU が偶然にも、USC-ISIC.ARPA の見つかった ARPA ドメインと C.ISI.EDU の情報が見つかった ISI.EDU ドメインとの両方に権威を持つために、この完全な回答が可能となる。
</p>
<p>
<span class="original">
If the same query was sent to C.ISI.EDU, its response might be the same
as shown above if it had its own address in its cache, but might also
be:
</span>
  同じ問合せが C.ISI.EDU に送られた場合の応答は、キャッシュにそれ自身のアドレスを持っていれば上記と同じになるだろうが、おそらくは以下のようになるだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE, AA                       |
               +---------------------------------------------------+
    Question   | QNAME=USC-ISIC.ARPA., QCLASS=IN, QTYPE=A          |
               +---------------------------------------------------+
    Answer     | USC-ISIC.ARPA.   86400 IN CNAME   C.ISI.EDU.      |
               +---------------------------------------------------+
    Authority  | ISI.EDU.        172800 IN NS      VAXA.ISI.EDU.   |
               |                           NS      A.ISI.EDU.      |
               |                           NS      VENERA.ISI.EDU. |
               +---------------------------------------------------+
    Additional | VAXA.ISI.EDU.   172800    A       10.2.0.27       |
               |                 172800    A       128.9.0.33      |
               | VENERA.ISI.EDU. 172800    A       10.1.0.52       |
               |                 172800    A       128.9.0.32      |
               | A.ISI.EDU.      172800    A       26.3.0.103      |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
This reply contains an authoritative reply for the alias USC-ISIC.ARPA,
plus a referral to the name servers for ISI.EDU.  This sort of reply
isn't very likely given that the query is for the host name of the name
server being asked, but would be common for other aliases.
</span>
  この回答はエイリアス USC-ISIC.ARPA のための権威ある回答と、加えて ISI.EDU のためのネームサーバーへの参照を含んでいる。この種類の回答は、尋ねられているネームサーバー自体のホスト名を問合せた場合にはありそうもないが、そうでないエイリアスの場合には一般的である。
</p>

<h4>
6.2.8. QNAME=USC-ISIC.ARPA, QTYPE=CNAME
</h4>
<p>
<span class="original">
If this query is sent to either A.ISI.EDU or C.ISI.EDU, the reply would
be:
</span>
  この問合せが A.ISI.EDU または C.ISI.EDU のどちらかに送られた場合、その回答は以下のようになるだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE, AA                       |
               +---------------------------------------------------+
    Question   | QNAME=USC-ISIC.ARPA., QCLASS=IN, QTYPE=A          |
               +---------------------------------------------------+
    Answer     | USC-ISIC.ARPA. 86400 IN CNAME      C.ISI.EDU.     |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
Because QTYPE=CNAME, the CNAME RR itself answers the query, and the name
server doesn't attempt to look up anything for C.ISI.EDU.  (Except
possibly for the additional section.)
</span>
  QTYPE=CNAME であるため、CNAME RR 自体が問合せの回答であり、ネームーサーバーは C.ISI.EDU に付いてそれ以上探そうとしない。(ただし Additional セクションのための例外はあるかもしれない。)
</p>

<h3>
<span class="original">
6.3. Example resolution
</span>
6.3. 解決の例
</h3>

<p>
<span class="original">
The following examples illustrate the operations a resolver must perform
for its client.  We assume that the resolver is starting without a
cache, as might be the case after system boot.  We further assume that
the system is not one of the hosts in the data and that the host is
located somewhere on net 26, and that its safety belt (SBELT) data
structure has the following information:
</span>
  以下の例は、リゾルバがクライアントのために実行しなければならない動作を表している。システムブートの後のように、リゾルバがキャッシュを持たない状態から始まると仮定する。さらに私たちは、そのシステムがその情報に含まれるホストのひとつではなく、そのホストがネット 26 上のどこかに存在し、安全ベルト(SBELT)情報構造体が以下の内容を持つと仮定する：
</p>
<pre>    Match count = -1
    SRI-NIC.ARPA.   26.0.0.73       10.0.0.51
    A.ISI.EDU.      26.3.0.103
</pre>
<p>
<span class="original">
This information specifies servers to try, their addresses, and a match
count of -1, which says that the servers aren't very close to the
target.  Note that the -1 isn't supposed to be an accurate closeness
measure, just a value so that later stages of the algorithm will work.
</span>
  この情報は試みるべきサーバーのアドレスと一致数 -1 とを表しており、このサーバーが目標から非常に遠いことを示している。-1 は正しい距離を表しているものではなく、アルゴリズムの後続処理を正しく動作させるための値であることに注意してほしい。
</p>
<p>
<span class="original">
The following examples illustrate the use of a cache, so each example
assumes that previous requests have completed.
</span>
  以下の例はキャッシュの使用法を表している。したがってそれぞれの例は前のリクエストが完了したと仮定している。
</p>

<h4>
<span class="original">
6.3.1. Resolve MX for ISI.EDU.
</span>
6.3.1. ISI.EDU の MX を解決する
</h4>

<p>
<span class="original">
Suppose the first request to the resolver comes from the local mailer,
which has mail for PVM@ISI.EDU.  The mailer might then ask for type MX
RRs for the domain name ISI.EDU.
</span>
  リゾルバへの最初の問合せが、PVM@ISI.EDU 宛てのメールを持つローカルメーラーから来たと仮定する。メーラーは次に、ドメイン名 ISI.EDU のタイプ MX の RR を要求するだろう。
</p>
<p>
<span class="original">
The resolver would look in its cache for MX RRs at ISI.EDU, but the
empty cache wouldn't be helpful.  The resolver would recognize that it
needed to query foreign servers and try to determine the best servers to
query.  This search would look for NS RRs for the domains ISI.EDU, EDU,
and the root.  These searches of the cache would also fail.  As a last
resort, the resolver would use the information from the SBELT, copying
it into its SLIST structure.
</span>
  リゾルバはキャッシュの中から ISI.EDU の MX RR を探そうとするが、キャッシュは空であるため役に立たない。リゾルバは、外部のサーバーに問合せ、問合せるべき最適なサーバーを決定する必要があることを認識するだろう。その検索ではドメイン ISI.EDU、EDU、ルートの NS RR を探すことになる。キャッシュからのそれらの検索は同じように失敗する。リゾルバは最後の手段として、SBELT の情報を SLIST 構造体にコピーして使用することになる。
</p>
<p>
<span class="original">
At this point the resolver would need to pick one of the three available
addresses to try.  Given that the resolver is on net 26, it should
choose either 26.0.0.73 or 26.3.0.103 as its first choice.  It would
then send off a query of the form:
</span>
  この時点でリゾルバは、利用可能な三つのアドレスからひとつを選択する必要がある。リゾルバがネット 26 上にあることを考えると、最初の選択として 26.0.0.73 または 26.3.0.103 を選択するべきである。リゾルバは次に以下の形式の問合せを送信するだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY                                     |
               +---------------------------------------------------+
    Question   | QNAME=ISI.EDU., QCLASS=IN, QTYPE=MX               |
               +---------------------------------------------------+
    Answer     | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
The resolver would then wait for a response to its query or a timeout.
If the timeout occurs, it would try different servers, then different
addresses of the same servers, lastly retrying addresses already tried.
It might eventually receive a reply from SRI-NIC.ARPA:
</span>
  次にリゾルバは、問合せに対する応答またはタイムアウトまで待機する。タイムアウトした場合、リゾルバは別のサーバーを試し、次に同じサーバーの別のアドレスを試し、最後にはすでに試したアドレスを再試行する。最終的にリゾルバは SRI-NIC.ARPA から以下の回答を受け取るだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE                           |
               +---------------------------------------------------+
    Question   | QNAME=ISI.EDU., QCLASS=IN, QTYPE=MX               |
               +---------------------------------------------------+
    Answer     | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Authority  | ISI.EDU.        172800 IN NS       VAXA.ISI.EDU.  |
               |                           NS       A.ISI.EDU.     |
               |                           NS       VENERA.ISI.EDU.|
               +---------------------------------------------------+
    Additional | VAXA.ISI.EDU.   172800    A        10.2.0.27      |
               |                 172800    A        128.9.0.33     |
               | VENERA.ISI.EDU. 172800    A        10.1.0.52      |
               |                 172800    A        128.9.0.32     |
               | A.ISI.EDU.      172800    A        26.3.0.103     |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
The resolver would notice that the information in the response gave a
closer delegation to ISI.EDU than its existing SLIST (since it matches
three labels).  The resolver would then cache the information in this
response and use it to set up a new SLIST:
</span>
  リゾルバは、この応答の情報が既知の SLIST よりも ISI.EDU に近い委譲を示していることに気付くだろう(三つのラベルが一致しているためである)。次にリゾルバは、この応答の情報をキャッシュし、それを使用して新しい SLIST を設定する：
</p>
<pre>    Match count = 3
    A.ISI.EDU.      26.3.0.103
    VAXA.ISI.EDU.   10.2.0.27       128.9.0.33
    VENERA.ISI.EDU. 10.1.0.52       128.9.0.32
</pre>
<p>
<span class="original">
A.ISI.EDU appears on this list as well as the previous one, but that is
purely coincidental.  The resolver would again start transmitting and
waiting for responses.  Eventually it would get an answer:
</span>
  このリスト上の A.ISI.EDU は前のリストにも現れていたが、これはまったくの偶然である。リゾルバは再び送信と応答の待機とを開始する。リゾルバは最終的に以下の回答を得るだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE, AA                       |
               +---------------------------------------------------+
    Question   | QNAME=ISI.EDU., QCLASS=IN, QTYPE=MX               |
               +---------------------------------------------------+
    Answer     | ISI.EDU.                MX 10 VENERA.ISI.EDU.     |
               |                         MX 20 VAXA.ISI.EDU.       |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | VAXA.ISI.EDU.   172800  A  10.2.0.27              |
               |                 172800  A  128.9.0.33             |
               | VENERA.ISI.EDU. 172800  A  10.1.0.52              |
               |                 172800  A  128.9.0.32             |
               +---------------------------------------------------+
</pre>
<p>
<span class="original">
The resolver would add this information to its cache, and return the MX
RRs to its client.
</span>
  リゾルバはこの情報をキャッシュに追加し、クライアントにこの MX RR を返す。
</p>

<h4>
<span class="original">
6.3.2. Get the host name for address 26.6.0.65
</span>
6.3.2. アドレス 26.6.0.65 のホスト名を取得する
</h4>

<p>
<span class="original">
The resolver would translate this into a request for PTR RRs for
65.0.6.26.IN-ADDR.ARPA.  This information is not in the cache, so the
resolver would look for foreign servers to ask.  No servers would match,
so it would use SBELT again.  (Note that the servers for the ISI.EDU
domain are in the cache, but ISI.EDU is not an ancestor of
65.0.6.26.IN-ADDR.ARPA, so the SBELT is used.)
</span>
  リゾルバはこれを、65.0.6.26.IN-ADDR.ARPA の PTR RR を求めるリクエストに変換する。この情報がキャッシュに存在しないため、リゾルバは尋ねるべき外部のサーバーを探す。しかしサーバーが見つからないため、リゾルバは再び SBELT を使用することになる。(ISI.EDU ドメインのためのサーバーがキャッシュに存在するが、ISI.EDU は 65.0.6.26.IN-ADDR.ARPA の上位ではないため、SBELT が使用される。)
</p>
<p>
<span class="original">
Since this request is within the authoritative data of both servers in
SBELT, eventually one would return:
</span>
  このリクエストは SBELT の中の両サーバーの権威情報内にあるので、最終的にそのひとつが以下の応答を返すだろう：
</p>
<pre>               +---------------------------------------------------+
    Header     | OPCODE=SQUERY, RESPONSE, AA                       |
               +---------------------------------------------------+
    Question   | QNAME=65.0.6.26.IN-ADDR.ARPA.,QCLASS=IN,QTYPE=PTR |
               +---------------------------------------------------+
    Answer     | 65.0.6.26.IN-ADDR.ARPA.    PTR     ACC.ARPA.      |
               +---------------------------------------------------+
    Authority  | &lt;empty&gt;                                           |
               +---------------------------------------------------+
    Additional | &lt;empty&gt;                                           |
               +---------------------------------------------------+
</pre>

<h4>
<span class="original">
6.3.3. Get the host address of poneria.ISI.EDU
</span>
6.3.3. poneria.ISI.EDU のホストアドレスを取得する
</h4>

<p>
<span class="original">
This request would translate into a type A request for poneria.ISI.EDU.
The resolver would not find any cached data for this name, but would
find the NS RRs in the cache for ISI.EDU when it looks for foreign
servers to ask.  Using this data, it would construct a SLIST of the
form:
</span>
  このリクエストは poneria.ISI.EDU のタイプ A のリクエストに変換される。リゾルバはキャッシュ情報にこの名前を見つけられない。しかし、尋ねるべき外部のサーバーを探すとき、キャッシュの中に ISI.EDU の NS RR を見つけるだろう。この情報を使用して、リゾルバは以下の形の SLIST を構築するだろう：
</p>
<pre>    Match count = 3

    A.ISI.EDU.      26.3.0.103
    VAXA.ISI.EDU.   10.2.0.27       128.9.0.33
    VENERA.ISI.EDU. 10.1.0.52
</pre>
<p>
<span class="original">
A.ISI.EDU is listed first on the assumption that the resolver orders its
choices by preference, and A.ISI.EDU is on the same network.
</span>
  A.ISI.EDU はリゾルバの優先順位による順序付け条件の先頭にリストされており、かつ A.ISI.EDU は同じネットワーク上にある。
  
</p>
<p>
<span class="original">
One of these servers would answer the query.
</span>
  これらのサーバーのひとつが問合せに回答するだろう。
</p>

<h2>
<span class="original">
7. REFERENCES and BIBLIOGRAPHY
</span>
7. 引用資料と参考資料
</h2>

<dl>
  <dt>[Dyer 87]</dt>
  <dd>
                Dyer, S., and F. Hsu, "Hesiod", Project Athena
                Technical Plan - Name Service, April 1987, version 1.9.
  </dd>
  <dd>
    <span class="original">
                Describes the fundamentals of the Hesiod name service.
    Hesiod ネームサービスの基礎を説明している。
    </span>
  </dd>
  <dt>[IEN-116]</dt>
  <dd>
               J. Postel, "Internet Name Server", IEN-116,
                USC/Information Sciences Institute, August 1979.
  </dd>
  <dd>
    <span class="original">
                A name service obsoleted by the Domain Name System, but
                still in use.
    </span>
    ドメインネームシステムによって時代遅れとなったが、今もなお使用されているネームサービス。
  </dd>
  <dt>[Quarterman 86]</dt>
  <dd>
                Quarterman, J., and J. Hoskins, "Notable Computer
                Networks",Communications of the ACM, October 1986,
                volume 29, number 10.
  </dd>
  <dt>[RFC-742]</dt>
  <dd>
                K. Harrenstien, "NAME/FINGER", RFC-742, Network
                Information Center, SRI International, December 1977.
  </dd>
  <dt>[RFC-768]</dt>
  <dd>
                J. Postel, "User Datagram Protocol", RFC-768,
                USC/Information Sciences Institute, August 1980.
  </dd>
  <dt>[RFC-793]</dt>
  <dd>
                J. Postel, "Transmission Control Protocol", RFC-793,
                USC/Information Sciences Institute, September 1981.
  </dd>
  <dt>[RFC-799]</dt>
  <dd>
                D. Mills, "Internet Name Domains", RFC-799, COMSAT,
                September 1981.
  </dd>
  <dd>
    <span class="original">
                Suggests introduction of a hierarchy in place of a flat
                name space for the Internet.
    </span>
    インターネットのために、フラットな名前空間ではなく階層構造の導入を提案している。
  </dd>
  <dt>[RFC-805] </dt>
  <dd>
                J. Postel, "Computer Mail Meeting Notes", RFC-805,
                USC/Information Sciences Institute, February 1982.
  </dd>
  <dt>[RFC-810] </dt>
  <dd>
                E. Feinler, K. Harrenstien, Z. Su, and V. White, "DOD
                Internet Host Table Specification", RFC-810, Network
                Information Center, SRI International, March 1982.
  </dd>
  <dd>
    <span class="original">
                Obsolete.  See RFC-952.
    </span>
    非推奨。RFC-952 参照。
  </dd>
  <dt>[RFC-811]</dt>
  <dd>
                K. Harrenstien, V. White, and E. Feinler, "Hostnames
                Server", RFC-811, Network Information Center, SRI
                International, March 1982.
  </dd>
  <dd>
    <span class="original">
                Obsolete.  See RFC-953.
    </span>
    非推奨。RFC-953 参照。
  </dd>
  <dt>[RFC-812]</dt>
  <dd>
                K. Harrenstien, and V. White, "NICNAME/WHOIS", RFC-812,
                Network Information Center, SRI International, March
                1982.
  </dd>
  <dt>[RFC-819]</dt>
  <dd>
                Z. Su, and J. Postel, "The Domain Naming Convention for
                Internet User Applications", RFC-819, Network
                Information Center, SRI International, August 1982.
  </dd>
  <dd>
    <span class="original">
                Early thoughts on the design of the domain system.
                Current implementation is completely different.
    </span>
    初期のドメインシステムの設計思想。現在の実装とはまったく異なる。
  </dd>
  <dt>[RFC-821]</dt>
  <dd>
                J. Postel, "Simple Mail Transfer Protocol", RFC-821,
                USC/Information Sciences Institute, August 1980.
  </dd>
  <dt>[RFC-830]</dt>
  <dd>
                Z. Su, "A Distributed System for Internet Name Service",
                RFC-830, Network Information Center, SRI International,
                October 1982.
  </dd>
  <dd>
    <span class="original">
                Early thoughts on the design of the domain system.
                Current implementation is completely different.
    </span>
    初期のドメインシステムの設計思想。現在の実装とはまったく異なる。
  </dd>
  <dt>[RFC-882]</dt>
  <dd>
                P. Mockapetris, "Domain names - Concepts and
                Facilities," RFC-882, USC/Information Sciences
                Institute, November 1983.
  </dd>
  <dd>
    <span class="original">
                Superceeded by this memo.
    </span>
    この文書により廃止された。
  </dd>
  <dt>[RFC-883]</dt>
  <dd>
                P. Mockapetris, "Domain names - Implementation and
                Specification," RFC-883, USC/Information Sciences
                Institute, November 1983.
  </dd>
  <dd>
    <span class="original">
                Superceeded by this memo.
    </span>
    この文書により廃止された。
  </dd>
  <dt>[RFC-920]</dt>
  <dd>
                J. Postel and J. Reynolds, "Domain Requirements",
                RFC-920, USC/Information Sciences Institute
                October 1984.
  </dd>
  <dd>
    <span class="original">
                Explains the naming scheme for top level domains.
    </span>
    トップレベルドメインのための命名スキームを説明している。
  </dd>
  <dt>[RFC-952]</dt>
  <dd>
                K. Harrenstien, M. Stahl, E. Feinler, "DoD Internet Host
                Table Specification", RFC-952, SRI, October 1985.
  </dd>
  <dd>
    <span class="original">
                Specifies the format of HOSTS.TXT, the host/address
                table replaced by the DNS.
    </span>
    DNS によって置き換えられたホスト/アドレスのテーブルである HOSTS.TXT のフォーマットを規定している。
  </dd>
  <dt>[RFC-953]</dt>
  <dd>
                K. Harrenstien, M. Stahl, E. Feinler, "HOSTNAME Server",
                RFC-953, SRI, October 1985.
  </dd>
  <dd>
    <span class="original">
                This RFC contains the official specification of the
                hostname server protocol, which is obsoleted by the DNS.
                This TCP based protocol accesses information stored in
                the RFC-952 format, and is used to obtain copies of the
                host table.
    </span>
    この RFC には、DNS によって時代遅れになったホスト名サーバープロトコルの公式な規定が含まれる。TCP ベースのこのプロトコルは、RFC-952 のフォーマットで保存されている情報にアクセスし、ホストテーブルのコピーを取得するために使用される。
  </dd>
  <dt>[RFC-973]</dt>
  <dd>
                P. Mockapetris, "Domain System Changes and
                Observations", RFC-973, USC/Information Sciences
                Institute, January 1986.
  </dd>
  <dd>
    <span class="original">
                Describes changes to RFC-882 and RFC-883 and reasons for
                them.  Now obsolete.
    </span>
    RFC-882 および RFC-883 への変更点とその理由を説明している。現在では非推奨である。
  </dd>
  <dt>[RFC-974]</dt>
  <dd>
                C. Partridge, "Mail routing and the domain system",
                RFC-974, CSNET CIC BBN Labs, January 1986.
  </dd>
  <dd>
    <span class="original">
                Describes the transition from HOSTS.TXT based mail
                addressing to the more powerful MX system used with the
                domain system.
    </span>
    HOSTS.TXT ベースのメールアドレッシングから、ドメインシステによるより強力な MX システムへの移行を説明している。
  </dd>
  <dt>[RFC-1001]</dt>
  <dd>
                NetBIOS Working Group, "Protocol standard for a NetBIOS
                service on a TCP/UDP transport: Concepts and Methods",
                RFC-1001, March 1987.
  </dd>
  <dd>
    <span class="original">
                This RFC and RFC-1002 are a preliminary design for
                NETBIOS on top of TCP/IP which proposes to base NetBIOS
                name service on top of the DNS.
    </span>
    この RFC と RFC-1002 とは TCP/IP 上の NETBIOS のための予備的設計であり、DNS 上で NetBIOS ネームサービスの基礎を成すよう提案されている。
  </dd>
  <dt>[RFC-1002]</dt>
  <dd>
                NetBIOS Working Group, "Protocol standard for a NetBIOS
                service on a TCP/UDP transport: Detailed
                Specifications", RFC-1002, March 1987.
  </dd>
  <dt>[RFC-1010]</dt>
  <dd>
                J. Reynolds and J. Postel, "Assigned Numbers", RFC-1010,
                USC/Information Sciences Institute, May 1987
  </dd>
  <dd>
    <span class="original">
                Contains socket numbers and mnemonics for host names,
                operating systems, etc.
    </span>
    ソケット番号、ホスト名のためのニーモニック、オペレーティングシステムなどを含む。
  </dd>
  <dt>[RFC-1031]</dt>
  <dd>
                W. Lazear, "MILNET Name Domain Transition", RFC-1031,
                November 1987.
  </dd>
  <dd>
    <span class="original">
                Describes a plan for converting the MILNET to the DNS.
    </span>
    MILNET から DNS への変換予定を説明している。
  </dd>
  <dt>[RFC-1032]</dt>
  <dd>
                M. K. Stahl, "Establishing a Domain - Guidelines for
                Administrators", RFC-1032, November 1987.
  </dd>
  <dd>
    <span class="original">
                Describes the registration policies used by the NIC to
                administer the top level domains and delegate subzones.
    </span>
    トップレベルドメインと委譲サブゾーンとを管理するために NIC が使用する登録ポリシーを説明している。
  </dd>
  <dt>[RFC-1033]</dt>
  <dd>
                M. K. Lottor, "Domain Administrators Operations Guide",
                RFC-1033, November 1987.
  </dd>
  <dd>
    <span class="original">
                A cookbook for domain administrators.
    </span>
    ドメイン管理者のための説明書。
  </dd>
  <dt>[Solomon 82]</dt>
  <dd>
                M. Solomon, L. Landweber, and D. Neuhengen, "The CSNET
                Name Server", Computer Networks, vol 6, nr 3, July 1982.
  </dd>
  <dd>
    <span class="original">
                Describes a name service for CSNET which is independent
                from the DNS and DNS use in the CSNET.
    </span>
    DNS から独立している CSNET のためのネームサービスと、CSNET における DNS の使用方法とを説明している。
  </dd>
</dl>

<h2>
<span class="original">
Index
</span>
索引
</h2>

<pre class="original">          A   12
          Absolute names   8
          Aliases   14, 31
          Authority   6
          AXFR   17

          Case of characters   7
          CH   12
          CNAME   12, 13, 31
          Completion queries   18

          Domain name   6, 7

          Glue RRs   20

          HINFO   12

          IN   12
          Inverse queries   16
          Iterative   4

          Label   7

          Mailbox names   9
          MX   12

          Name error   27, 36
          Name servers   5, 17
          NE   30
          Negative caching   44
          NS   12

          Opcode   16

          PTR   12

          QCLASS   16
          QTYPE   16

          RDATA   13
          Recursive   4
          Recursive service   22
          Relative names   7
          Resolvers   6
          RR   12

          Safety belt   33
          Sections   16
          SOA   12
          Standard queries   22

          Status queries   18
          Stub resolvers   32

          TTL   12, 13

          Wildcards   25

          Zone transfers   28
          Zones   19
</pre>
<pre>    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-A">A</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-ABSOLUTENAME">絶対名(Absolute name)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-ALIASES1">エイリアス(Aliases)</a>　<a href="http://srgia.com/docs/rfc1034j.html#INDEX-ALIASES2">2</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-AUTHORITY">権威(Authority)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-AXFR">AXFR</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-CASEOFCHARACTERS">大文字・小文字(Case of characters)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-CH">CH</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-CNAME1">CNAME</a>　<a href="http://srgia.com/docs/rfc1034j.html#INDEX-CNAME2">2</a>　<a href="http://srgia.com/docs/rfc1034j.html#INDEX-CNAME3">3</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-COMPLETIONQUERIES">補完問合せ(Completion queries)</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-DOMAINNAME">ドメイン名(Domain name)</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-GLUERRS">グルー RR(Glue RRs)</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-HINFO">HINFO</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-IN">IN</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-INVERSEQUERIES">逆問合せ(Inverse queries)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-ITERATIVE">反復(Iterative)</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-LABEL">ラベル(Label)</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-MAILBOXNAMES">メールボックス名(Mailbox names)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-MX">MX</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-NAMEERROR1">名前エラー(Name error)</a>　<a href="http://srgia.com/docs/rfc1034j.html#INDEX-NAMEERROR2">2</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-NAMESERVERS1">ネームサーバー(Name servers)</a>　 <a href="http://srgia.com/docs/rfc1034j.html#INDEX-NAMESERVERS2">2</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-NE">NE</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-NEGATIVECACHING">否定キャッシュ(Negative caching)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-NS">NS</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-OPCODE">Opcode</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-PTR">PTR</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-QCLASS">QCLASS</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-QTYPE">QTYPE</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-RDATA">RDATA</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-RECURSIVE">再帰(Recursive)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-RECURSIVESERVICE">再帰サービス(Recursive service)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-RELATIVENAMES">相対名(Relative names)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-RESOLVERS">リゾルバ(Resolvers)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-RR">RR</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-SAFETYBELT">安全ベルト(Safety belt)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-SECTIONS">セクション(Sections)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-SOA">SOA</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-STANDARDQUERIES">標準問合せ(Standard queries)</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-STATUSQUERIES">状態問合せ(Status queries)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-STUBRESOLVERS">スタブリゾルバ(Stub resolvers)</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-TTL1">TTL</a>, <a href="http://srgia.com/docs/rfc1034j.html#INDEX-TTL2">2</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-WILDCARDS">ワイルドカード(Wildcards)</a>

    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-ZONETRANSFERS">ゾーン転送(Zone transfers)</a>
    <a href="http://srgia.com/docs/rfc1034j.html#INDEX-ZONES">ゾーン(Zones)</a>
</pre>
  <p class="dir_link">
    <a href="http://srgia.com/index.html">トップページ</a> - <a href="http://srgia.com/index.html#doc">翻訳ドキュメント</a> - RFC 1034
  </p>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-1272846-2";
urchinTracker();
</script>



</body></html>